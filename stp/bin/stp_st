#!/bin/bash
# stp_st - Manage steel threads (v1.2.1 - Directory-based structure)
# Usage: stp_st <command> [options] [arguments]

# Exit on error
set -e

# Function to display error messages
error() {
  echo "Error: $1" >&2
  exit 1
}

# Function to display usage information
usage() {
  echo "Usage: stp st <command> [options] [arguments]"
  echo ""
  echo "Manage steel threads for the project"
  echo ""
  echo "Commands:"
  echo "  new <title>                       Create a new steel thread"
  echo "  done <id>                         Mark a steel thread as complete"
  echo "  list [--status <status>] [--width N] List all steel threads"
  echo "  sync [--write] [--width N]        Synchronize steel_threads.md with individual ST files"
  echo "  organize [--write]                Organize ST files in directories by status"
  echo "  show <id> [file]                  Show details of a specific steel thread"
  echo "  edit <id> [file]                  Open a steel thread in your default editor"
  echo ""
  echo "File options for show/edit commands:"
  echo "  info    - Main information file (default)"
  echo "  design  - Design decisions and approach"
  echo "  impl    - Implementation details"
  echo "  tasks   - Task tracking"
  echo "  results - Results and outcomes"
  echo "  all     - Show all files combined (show only)"
  echo ""
  echo "Examples:"
  echo "  stp st new \"Implement Feature X\""
  echo "  stp st done ST0001"
  echo "  stp st list --status \"In Progress\" --width 100"
  echo "  stp st show ST0001"
  echo "  stp st show ST0001 design"
  echo "  stp st edit ST0001 impl"
  exit 1
}

# Check for required arguments
if [ $# -lt 1 ]; then
  error "Steel thread command is required"
  usage
fi

# Load project configuration if available
if [ -f stp/.config/config ]; then
  source stp/.config/config
elif [ -f .stp-config ]; then
  # For backward compatibility
  source .stp-config
fi

# Get command
ST_COMMAND="$1"
shift

# Function to check if we're using directory structure (v1.2.1+)
is_directory_structure() {
  local stp_version=$(grep -m 1 "^stp_version:" stp/.config/version 2>/dev/null | sed "s/^stp_version: *//")
  if [[ "$stp_version" > "1.2.0" ]] || [[ "$stp_version" == "1.2.1" ]]; then
    return 0  # true - using directory structure
  else
    return 1  # false - using file structure
  fi
}

# Function to determine the appropriate path for a steel thread based on its status
get_st_path() {
  local st_id="$1"
  local status="$2"
  local file_name="${3:-info.md}"  # Default to info.md
  local base_dir="stp/prj/st"
  local test_env=0
  
  # Check if we're in a test environment
  if [[ "${TEST_TEMP_DIR:-}" != "" ]] || [[ "$(pwd)" == /tmp* ]] || [[ "$(pwd)" == */stp/tests/* ]]; then
    test_env=1
  fi
  
  # For directory structure
  if is_directory_structure; then
    # If we're in a test environment, just use the main directory
    if [ $test_env -eq 1 ]; then
      echo "$base_dir/$st_id/$file_name"
      return
    fi
    
    # If status is not provided, try to find the steel thread directory
    if [ -z "$status" ]; then
      # Check all possible locations
      local possible_locations=(
        "$base_dir/$st_id"
        "$base_dir/COMPLETED/$st_id"
        "$base_dir/NOT-STARTED/$st_id"
        "$base_dir/CANCELLED/$st_id"
      )
      
      for location in "${possible_locations[@]}"; do
        if [ -d "$location" ]; then
          # Read status from info.md
          if [ -f "$location/info.md" ]; then
            yaml_status=$(grep -m 1 "^status:" "$location/info.md" | sed "s/^status: *//")
            body_status=$(grep -m 1 "^\- \*\*Status\*\*:" "$location/info.md" | sed "s/^\- \*\*Status\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # Prioritize YAML frontmatter status
            if [ -n "$yaml_status" ]; then
              status="$yaml_status"
            elif [ -n "$body_status" ]; then
              status="$body_status"
            else
              status="Not Started"
            fi
          fi
          break
        fi
      done
    fi
    
    # Return the appropriate directory based on status
    if [ $test_env -eq 1 ]; then
      echo "$base_dir/$st_id/$file_name"
    else
      case "$status" in
        "Completed")
          echo "$base_dir/COMPLETED/$st_id/$file_name"
          ;;
        "Not Started")
          echo "$base_dir/NOT-STARTED/$st_id/$file_name"
          ;;
        "Cancelled")
          echo "$base_dir/CANCELLED/$st_id/$file_name"
          ;;
        *)
          # In Progress or On Hold stay in the main directory
          echo "$base_dir/$st_id/$file_name"
          ;;
      esac
    fi
  else
    # Legacy file structure - ignore file_name parameter
    if [ $test_env -eq 1 ]; then
      echo "$base_dir/$st_id.md"
    else
      case "$status" in
        "Completed")
          echo "$base_dir/COMPLETED/$st_id.md"
          ;;
        "Not Started")
          echo "$base_dir/NOT-STARTED/$st_id.md"
          ;;
        "Cancelled")
          echo "$base_dir/CANCELLED/$st_id.md"
          ;;
        *)
          echo "$base_dir/$st_id.md"
          ;;
      esac
    fi
  fi
}

# Function to get the next steel thread ID
get_next_steel_thread_id() {
  local st_prefix="${ST_PREFIX:-ST}"
  local base_dir="stp/prj/st"
  local next_id=1
  local max_id=0
  
  if is_directory_structure; then
    # Find all ST directories
    for dir in $(find "$base_dir" -type d -name "$st_prefix[0-9][0-9][0-9][0-9]" 2>/dev/null); do
      # Extract numeric part of directory name
      local id_str=$(basename "$dir")
      id_str=${id_str#$st_prefix}
      
      # Convert to number and compare
      if [[ "$id_str" =~ ^[0-9]+$ ]]; then
        local id=$((10#$id_str))
        if [ $id -gt $max_id ]; then
          max_id=$id
        fi
      fi
    done
  else
    # Legacy: Find all ST files
    for file in $(find "$base_dir" -type f -name "$st_prefix[0-9][0-9][0-9][0-9].md" 2>/dev/null); do
      local id_str=$(basename "$file" .md)
      id_str=${id_str#$st_prefix}
      
      if [[ "$id_str" =~ ^[0-9]+$ ]]; then
        local id=$((10#$id_str))
        if [ $id -gt $max_id ]; then
          max_id=$id
        fi
      fi
    done
  fi
  
  # Increment for the next ID
  next_id=$((max_id + 1))
  
  # Format with leading zeros (4 digits)
  printf "%s%04d" "$st_prefix" $next_id
}

# Function to update steel threads index
update_steel_threads_index() {
  local id="$1"
  local title="$2"
  local status="$3"
  local created="$4"
  local completed="$5"
  local index_file="stp/prj/st/steel_threads.md"
  
  # Create index file if it doesn't exist
  if [ ! -f "$index_file" ]; then
    mkdir -p "$(dirname "$index_file")"
    cat > "$index_file" << EOF
# Steel Threads

This document serves as an index of all steel threads in the project.

## Index

| ID                       | Title                  | Status       | Created    | Completed  |
| ----------------------- | -------------------- | ------------ | ---------- | ---------- |
EOF
  fi
  
  # Check if entry already exists
  if grep -q "^| $id " "$index_file"; then
    # Update existing entry
    sed -i.bak "s/^| $id .*$/| $id | $title | $status | $created | $completed |/" "$index_file"
    rm -f "$index_file.bak"
  else
    # Add new entry
    echo "| $id | $title | $status | $created | $completed |" >> "$index_file"
  fi
}

# Normalize the command (handle alternative spelling)
if [ "$ST_COMMAND" = "organise" ]; then
  ST_COMMAND="organize"
fi

# Handle different commands
case "$ST_COMMAND" in
  "new")
    # Check for required arguments
    if [ $# -lt 1 ]; then
      error "Steel thread title is required"
      usage
    fi
    
    TITLE="$1"
    ST_ID=$(get_next_steel_thread_id)
    ST_STATUS="Not Started"
    DATE=$(date '+%Y-%m-%d')
    AUTHOR="${STP_AUTHOR:-${AUTHOR:-$(git config user.name 2>/dev/null || echo "$USER")}}"
    
    if is_directory_structure; then
      # Create directory structure
      ST_DIR=$(dirname $(get_st_path "$ST_ID" "$ST_STATUS" "info.md"))
      mkdir -p "$ST_DIR"
      
      # Create files from templates
      # Try to find templates relative to script location
      SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
      TEMPLATE_DIR="${SCRIPT_DIR}/../_templ/prj/st/ST####"
      
      # Also check in current directory (for tests)
      if [ ! -d "$TEMPLATE_DIR" ] && [ -d "stp/_templ/prj/st/ST####" ]; then
        TEMPLATE_DIR="stp/_templ/prj/st/ST####"
      fi
      
      if [ -d "$TEMPLATE_DIR" ]; then
        # Format date in both formats
        DATE_COMPACT=$(date '+%Y%m%d')
        DATE_VERBOSE=$(date '+%d %b %Y')
        
        # Copy and process each template file
        for template in "$TEMPLATE_DIR"/*.md; do
          if [ -f "$template" ]; then
            filename=$(basename "$template")
            output_file="$ST_DIR/$filename"
            
            sed -e "s/ST####/$ST_ID/g" \
                -e "s/\[Title\]/$TITLE/g" \
                -e "s/\[Not Started|In Progress|Completed|On Hold|Cancelled\]/$ST_STATUS/g" \
                -e "s/YYYY-MM-DD/$DATE/g" \
                -e "s/YYYYMMDD/$DATE_COMPACT/g" \
                -e "s/\[Date\]/$DATE_VERBOSE/g" \
                -e "s/\[Author Name\]/$AUTHOR/g" \
                -e "s/\[Author\]/$AUTHOR/g" \
                "$template" > "$output_file"
          fi
        done
      else
        # Create minimal info.md if no templates
        cat > "$ST_DIR/info.md" << EOF
---
verblock: "$(date '+%d %b %Y'):v0.1: $AUTHOR - Initial version"
stp_version: 1.2.1
status: $ST_STATUS
created: $(date '+%Y%m%d')
completed: 
---
# $ST_ID: $TITLE

- **Status**: $ST_STATUS
- **Created**: $DATE
- **Completed**: 
- **Author**: $AUTHOR

## Objective

[Clear statement of what this steel thread aims to accomplish]

## Context

[Background information and context for this steel thread]

## Related Steel Threads

- [List any related steel threads here]
EOF
      fi
      
      echo "Created steel thread directory: $ST_DIR"
      echo "Main file: $ST_DIR/info.md"
    else
      # Legacy: Create single file
      ST_FILE=$(get_st_path "$ST_ID" "$ST_STATUS")
      mkdir -p "$(dirname "$ST_FILE")"
      
      if [ -f "stp/_templ/prj/st/_ST####.md" ]; then
        DATE_COMPACT=$(date '+%Y%m%d')
        
        sed -e "s/ST####/$ST_ID/g" \
            -e "s/\[Title\]/$TITLE/g" \
            -e "s/\[Not Started|In Progress|Completed|On Hold|Cancelled\]/$ST_STATUS/g" \
            -e "s/YYYY-MM-DD/$DATE/g" \
            -e "s/YYYYMMDD/$DATE_COMPACT/g" \
            -e "s/\[Author Name\]/$AUTHOR/g" \
            "stp/_templ/prj/st/_ST####.md" > "$ST_FILE"
      fi
      
      echo "Created steel thread: $ST_ID: $TITLE"
      echo "Edit file: $ST_FILE"
    fi
    
    # Update index
    update_steel_threads_index "$ST_ID" "$TITLE" "$ST_STATUS" "$DATE" ""
    ;;
    
  "done")
    # Check for required arguments
    if [ $# -lt 1 ]; then
      error "Steel thread ID is required"
      usage
    fi
    
    # Process the steel thread ID
    ST_ID="$1"
    
    # If just a number is provided, format it as ST#### (with leading zeros)
    if [[ "$ST_ID" =~ ^[0-9]+$ ]]; then
      ST_ID=$(printf "ST%04d" "$ST_ID")
    # If the ID doesn't start with ST, prepend it
    elif [[ ! "$ST_ID" =~ ^ST ]]; then
      ST_ID="ST$ST_ID"
    fi
    
    DATE=$(date '+%Y-%m-%d')
    
    if is_directory_structure; then
      # Find the info.md file
      ST_FILE=$(get_st_path "$ST_ID" "" "info.md")
      
      # Check if steel thread exists
      if [ ! -f "$ST_FILE" ]; then
        error "Steel thread not found: $ST_ID"
      fi
      
      # Extract title
      TITLE=$(grep "^# $ST_ID:" "$ST_FILE" | sed "s/^# $ST_ID: //")
      
      # Update status and completion date
      sed -i.bak "s/^\- \*\*Status\*\*: .*$/- **Status**: Completed/" "$ST_FILE"
      sed -i.bak "s/^\- \*\*Completed\*\*: .*$/- **Completed**: $DATE/" "$ST_FILE"
      sed -i.bak "s/^status: .*$/status: Completed/" "$ST_FILE"
      sed -i.bak "s/^completed: .*$/completed: $(date '+%Y%m%d')/" "$ST_FILE"
      rm -f "$ST_FILE.bak"
      
      # Get current directory
      CURRENT_DIR=$(dirname "$ST_FILE")
      
      # Get the target location
      NEW_ST_FILE=$(get_st_path "$ST_ID" "Completed" "info.md")
      NEW_DIR=$(dirname "$NEW_ST_FILE")
      
      # Move the entire directory if it's different
      if [ "$CURRENT_DIR" != "$NEW_DIR" ]; then
        mkdir -p "$(dirname "$NEW_DIR")"
        mv "$CURRENT_DIR" "$NEW_DIR"
        echo "Moved steel thread to: $NEW_DIR"
      fi
    else
      # Legacy: Handle single file
      ST_FILE=$(get_st_path "$ST_ID")
      
      if [ ! -f "$ST_FILE" ]; then
        error "Steel thread not found: $ST_ID"
      fi
      
      TITLE=$(grep "^# $ST_ID:" "$ST_FILE" | sed "s/^# $ST_ID: //")
      
      sed -i.bak "s/^\- \*\*Status\*\*: .*$/- **Status**: Completed/" "$ST_FILE"
      sed -i.bak "s/^\- \*\*Completed\*\*: .*$/- **Completed**: $DATE/" "$ST_FILE"
      sed -i.bak "s/^status: .*$/status: Completed/" "$ST_FILE"
      sed -i.bak "s/^completed: .*$/completed: $(date '+%Y%m%d')/" "$ST_FILE"
      rm -f "$ST_FILE.bak"
      
      NEW_ST_FILE=$(get_st_path "$ST_ID" "Completed")
      
      if [ "$ST_FILE" != "$NEW_ST_FILE" ]; then
        mkdir -p "$(dirname "$NEW_ST_FILE")"
        mv "$ST_FILE" "$NEW_ST_FILE"
        echo "Moved steel thread to: $NEW_ST_FILE"
      fi
    fi
    
    # Update index
    update_steel_threads_index "$ST_ID" "$TITLE" "Completed" "$(grep '^\- \*\*Created\*\*:' "$ST_FILE" 2>/dev/null | sed 's/^\- \*\*Created\*\*: //' || echo "$DATE")" "$DATE"
    
    echo "Marked steel thread as complete: $ST_ID: $TITLE"
    ;;
    
  "list")
    # Parse options
    STATUS=""
    WIDTH=0  # Default to terminal width
    while [ $# -gt 0 ]; do
      case "$1" in
        --status)
          shift
          STATUS="$1"
          shift
          ;;
        --width)
          shift
          WIDTH="$1"
          shift
          ;;
        *)
          error "Unknown option: $1"
          ;;
      esac
    done
    
    ST_DIR="stp/prj/st"
    
    # Check if ST directory exists
    if [ ! -d "$ST_DIR" ]; then
      error "Steel threads directory not found"
    fi
    
    # Determine table width (same as original)
    if [ "$WIDTH" -gt 0 ]; then
      TABLE_WIDTH=$WIDTH
    else
      if [ "$ST_COMMAND" = "sync" ] && [ $WRITE_MODE -eq 1 ]; then
        TABLE_WIDTH=80
      else
        if [ -n "$COLUMNS" ]; then
          TABLE_WIDTH=$COLUMNS
        elif [ -t 1 ]; then
          STTY_SIZE=$( (stty size 2>/dev/null || echo "24 80") | cut -d' ' -f2)
          if [ -n "$STTY_SIZE" ] && [ "$STTY_SIZE" -gt 0 ]; then
            TABLE_WIDTH=$STTY_SIZE
          else
            TPUT_COLS=$(tput cols 2>/dev/null || echo 80)
            TABLE_WIDTH=$TPUT_COLS
          fi
        else
          TABLE_WIDTH=80
        fi
      fi
    fi
    
    # Calculate column widths (same as original)
    MIN_ID_WIDTH=10
    MIN_STATUS_WIDTH=12
    MIN_DATE_WIDTH=10
    MIN_TITLE_WIDTH=20
    
    FIXED_MIN_WIDTH=$((MIN_ID_WIDTH + MIN_STATUS_WIDTH + MIN_DATE_WIDTH + MIN_DATE_WIDTH))
    SEPARATORS_WIDTH=13
    AVAILABLE_WIDTH=$((TABLE_WIDTH - SEPARATORS_WIDTH))
    
    if [ $AVAILABLE_WIDTH -lt $((FIXED_MIN_WIDTH + MIN_TITLE_WIDTH)) ]; then
      ID_WIDTH=$MIN_ID_WIDTH
      STATUS_WIDTH=$MIN_STATUS_WIDTH
      DATE_WIDTH=$MIN_DATE_WIDTH
      TITLE_WIDTH=$MIN_TITLE_WIDTH
    else
      if [ $AVAILABLE_WIDTH -le 100 ]; then
        ID_WIDTH=$MIN_ID_WIDTH
        STATUS_WIDTH=$MIN_STATUS_WIDTH
        DATE_WIDTH=$MIN_DATE_WIDTH
        
        MAX_TITLE_PCT=50
        MAX_TITLE_WIDTH=$((AVAILABLE_WIDTH * MAX_TITLE_PCT / 100))
        TITLE_WIDTH=$((AVAILABLE_WIDTH - MIN_ID_WIDTH - MIN_STATUS_WIDTH - MIN_DATE_WIDTH - MIN_DATE_WIDTH))
        
        [ $TITLE_WIDTH -gt $MAX_TITLE_WIDTH ] && TITLE_WIDTH=$MAX_TITLE_WIDTH
        
        REMAINING=$((AVAILABLE_WIDTH - ID_WIDTH - STATUS_WIDTH - DATE_WIDTH - DATE_WIDTH - TITLE_WIDTH))
        if [ $REMAINING -gt 0 ]; then
          STATUS_WIDTH=$((STATUS_WIDTH + (REMAINING * 4 / 10)))
          DATE_WIDTH=$((DATE_WIDTH + (REMAINING * 3 / 10)))
          ID_WIDTH=$((ID_WIDTH + (REMAINING * 3 / 10)))
        fi
      else
        ID_WIDTH=$((AVAILABLE_WIDTH * 10 / 100))
        STATUS_WIDTH=$((AVAILABLE_WIDTH * 15 / 100))
        DATE_WIDTH=$((AVAILABLE_WIDTH * 10 / 100))
        TITLE_WIDTH=$((AVAILABLE_WIDTH * 55 / 100))

        [ $ID_WIDTH -lt $MIN_ID_WIDTH ] && ID_WIDTH=$MIN_ID_WIDTH
        [ $STATUS_WIDTH -lt $MIN_STATUS_WIDTH ] && STATUS_WIDTH=$MIN_STATUS_WIDTH
        [ $DATE_WIDTH -lt $MIN_DATE_WIDTH ] && DATE_WIDTH=$MIN_DATE_WIDTH
        [ $TITLE_WIDTH -lt $MIN_TITLE_WIDTH ] && TITLE_WIDTH=$MIN_TITLE_WIDTH
        
        TOTAL=$((ID_WIDTH + STATUS_WIDTH + DATE_WIDTH + DATE_WIDTH + TITLE_WIDTH))
        if [ $TOTAL -gt $AVAILABLE_WIDTH ]; then
          TITLE_WIDTH=$((TITLE_WIDTH - (TOTAL - AVAILABLE_WIDTH)))
        fi
      fi
    fi
    
    # Function to truncate string with ellipsis if too long
    truncate_string() {
      local string="$1"
      local width=$2
      
      if [ -z "$string" ]; then
        echo ""
        return
      fi
      
      if [ ${#string} -gt $width ]; then
        if [ $width -le 5 ]; then
          echo "${string:0:$width}"
        else
          echo "${string:0:$((width-3))}..."
        fi
      else
        echo "$string"
      fi
    }
    
    # Display header
    printf "%-${ID_WIDTH}s | %-${TITLE_WIDTH}s | %-${STATUS_WIDTH}s | %-${DATE_WIDTH}s | %-${DATE_WIDTH}s\n" \
      "ID" "Title" "Status" "Created" "Completed"
    printf "%-${ID_WIDTH}s-|-%-${TITLE_WIDTH}s-|-%-${STATUS_WIDTH}s-|-%-${DATE_WIDTH}s-|-%-${DATE_WIDTH}s\n" \
      "$(printf '%0.s-' $(seq 1 $ID_WIDTH))" \
      "$(printf '%0.s-' $(seq 1 $TITLE_WIDTH))" \
      "$(printf '%0.s-' $(seq 1 $STATUS_WIDTH))" \
      "$(printf '%0.s-' $(seq 1 $DATE_WIDTH))" \
      "$(printf '%0.s-' $(seq 1 $DATE_WIDTH))"
    
    # Collect data from steel threads
    declare -a st_data
    
    if is_directory_structure; then
      # Loop through all ST directories
      for dir in $(find "$ST_DIR" -type d -name "ST[0-9][0-9][0-9][0-9]"); do
        if [ -f "$dir/info.md" ]; then
          # Extract ID from directory name
          ID=$(basename "$dir")
          
          # Read metadata from info.md
          file="$dir/info.md"
          
          YAML_STATUS=$(grep -m 1 "^status:" "$file" | sed "s/^status: *//")
          BODY_STATUS=$(grep -m 1 "^\- \*\*Status\*\*:" "$file" | sed "s/^\- \*\*Status\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          if [ -n "$YAML_STATUS" ]; then
            ST_STATUS="$YAML_STATUS"
          elif [ -n "$BODY_STATUS" ]; then
            ST_STATUS="$BODY_STATUS"
          else
            ST_STATUS="Not Started"
          fi
          
          TITLE=$(grep "^# $ID:" "$file" | sed "s/^# $ID: //")
          
          CREATED=$(grep -m 1 "^\- \*\*Created\*\*:" "$file" | sed "s/^\- \*\*Created\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          COMPLETED=$(grep -m 1 "^\- \*\*Completed\*\*:" "$file" | sed "s/^\- \*\*Completed\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # Handle date formats (same as original)
          if [ -z "$CREATED" ] || [ "$CREATED" = "YYYY-MM-DD" ]; then
            YAML_CREATED=$(grep -m 1 "^created:" "$file" | sed "s/^created: *//")
            if [ -n "$YAML_CREATED" ] && [ "$YAML_CREATED" != "YYYYMMDD" ]; then
              if [[ "$YAML_CREATED" =~ ^[0-9]{8}$ ]]; then
                CREATED="${YAML_CREATED:0:4}-${YAML_CREATED:4:2}-${YAML_CREATED:6:2}"
              else
                CREATED="$YAML_CREATED"
              fi
            else
              CREATED=$(date '+%Y-%m-%d')
            fi
          fi
          
          if [ -z "$COMPLETED" ] || [ "$COMPLETED" = "YYYY-MM-DD" ]; then
            YAML_COMPLETED=$(grep -m 1 "^completed:" "$file" | sed "s/^completed: *//")
            if [ -n "$YAML_COMPLETED" ] && [ "$YAML_COMPLETED" != "null" ] && [ "$YAML_COMPLETED" != "~" ] && [ "$YAML_COMPLETED" != "YYYYMMDD" ]; then
              if [[ "$YAML_COMPLETED" =~ ^[0-9]{8}$ ]]; then
                COMPLETED="${YAML_COMPLETED:0:4}-${YAML_COMPLETED:4:2}-${YAML_COMPLETED:6:2}"
              else
                COMPLETED="$YAML_COMPLETED"
              fi
            fi
          fi
          
          # Skip if the requested status doesn't match
          if [ -n "$STATUS" ] && [ "$STATUS" != "$ST_STATUS" ]; then
            continue
          fi
          
          st_data+=("$ID|$TITLE|$ST_STATUS|$CREATED|$COMPLETED")
        fi
      done
    else
      # Legacy: Loop through all ST####.md files
      for file in $(find "$ST_DIR" -type f -name "ST[0-9][0-9][0-9][0-9].md"); do
        if [ -f "$file" ]; then
          ID=$(basename "$file" .md)
          
          # (Rest of legacy processing same as original)
          YAML_STATUS=$(grep -m 1 "^status:" "$file" | sed "s/^status: *//")
          BODY_STATUS=$(grep -m 1 "^\- \*\*Status\*\*:" "$file" | sed "s/^\- \*\*Status\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          if [ -n "$YAML_STATUS" ]; then
            ST_STATUS="$YAML_STATUS"
          elif [ -n "$BODY_STATUS" ]; then
            ST_STATUS="$BODY_STATUS"
          else
            ST_STATUS="Not Started"
          fi
          
          TITLE=$(grep "^# $ID:" "$file" | sed "s/^# $ID: //")
          
          CREATED=$(grep -m 1 "^\- \*\*Created\*\*:" "$file" | sed "s/^\- \*\*Created\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          COMPLETED=$(grep -m 1 "^\- \*\*Completed\*\*:" "$file" | sed "s/^\- \*\*Completed\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          if [ -z "$CREATED" ] || [ "$CREATED" = "YYYY-MM-DD" ]; then
            YAML_CREATED=$(grep -m 1 "^created:" "$file" | sed "s/^created: *//")
            if [ -n "$YAML_CREATED" ] && [ "$YAML_CREATED" != "YYYYMMDD" ]; then
              if [[ "$YAML_CREATED" =~ ^[0-9]{8}$ ]]; then
                CREATED="${YAML_CREATED:0:4}-${YAML_CREATED:4:2}-${YAML_CREATED:6:2}"
              else
                CREATED="$YAML_CREATED"
              fi
            else
              CREATED=$(date '+%Y-%m-%d')
            fi
          fi
          
          if [ -z "$COMPLETED" ] || [ "$COMPLETED" = "YYYY-MM-DD" ]; then
            YAML_COMPLETED=$(grep -m 1 "^completed:" "$file" | sed "s/^completed: *//")
            if [ -n "$YAML_COMPLETED" ] && [ "$YAML_COMPLETED" != "null" ] && [ "$YAML_COMPLETED" != "~" ] && [ "$YAML_COMPLETED" != "YYYYMMDD" ]; then
              if [[ "$YAML_COMPLETED" =~ ^[0-9]{8}$ ]]; then
                COMPLETED="${YAML_COMPLETED:0:4}-${YAML_COMPLETED:4:2}-${YAML_COMPLETED:6:2}"
              else
                COMPLETED="$YAML_COMPLETED"
              fi
            fi
          fi
          
          if [ -n "$STATUS" ] && [ "$STATUS" != "$ST_STATUS" ]; then
            continue
          fi
          
          st_data+=("$ID|$TITLE|$ST_STATUS|$CREATED|$COMPLETED")
        fi
      done
    fi
    
    # Sort by ID in reverse order (newest first)
    IFS=$'\n' sorted_data=($(sort -r <<<"${st_data[*]}"))
    unset IFS
    
    # Process and display rows
    for line in "${sorted_data[@]}"; do
      ID=$(echo "$line" | cut -d'|' -f1)
      TITLE=$(echo "$line" | cut -d'|' -f2)
      ST_STATUS=$(echo "$line" | cut -d'|' -f3)
      CREATED=$(echo "$line" | cut -d'|' -f4)
      COMPLETED=$(echo "$line" | cut -d'|' -f5)
      
      # Truncate values if needed
      ID_TRUNC=$(truncate_string "$ID" $ID_WIDTH)
      TITLE_TRUNC=$(truncate_string "$TITLE" $TITLE_WIDTH)
      STATUS_TRUNC=$(truncate_string "$ST_STATUS" $STATUS_WIDTH)
      CREATED_TRUNC=$(truncate_string "$CREATED" $DATE_WIDTH)
      COMPLETED_TRUNC=$(truncate_string "$COMPLETED" $DATE_WIDTH)
      
      printf "%-${ID_WIDTH}s | %-${TITLE_WIDTH}s | %-${STATUS_WIDTH}s | %-${DATE_WIDTH}s | %-${DATE_WIDTH}s\n" \
        "$ID_TRUNC" "$TITLE_TRUNC" "$STATUS_TRUNC" "$CREATED_TRUNC" "$COMPLETED_TRUNC"
    done
    ;;
    
  "show")
    # Check for required arguments
    if [ $# -lt 1 ]; then
      error "Steel thread ID is required"
      usage
    fi
    
    # Process the steel thread ID
    ST_ID="$1"
    FILE_TYPE="${2:-info}"  # Default to info
    
    # If just a number is provided, format it as ST#### (with leading zeros)
    if [[ "$ST_ID" =~ ^[0-9]+$ ]]; then
      ST_ID=$(printf "ST%04d" "$ST_ID")
    elif [[ ! "$ST_ID" =~ ^ST ]]; then
      ST_ID="ST$ST_ID"
    fi
    
    if is_directory_structure; then
      if [ "$FILE_TYPE" = "all" ]; then
        # Show all files in the steel thread directory
        ST_DIR=$(dirname $(get_st_path "$ST_ID" "" "info.md"))
        
        if [ ! -d "$ST_DIR" ]; then
          error "Steel thread not found: $ST_ID"
        fi
        
        # Display each file with a header
        for file in info.md design.md impl.md tasks.md results.md; do
          if [ -f "$ST_DIR/$file" ]; then
            echo "=== $file ==="
            cat "$ST_DIR/$file"
            echo ""
          fi
        done
      else
        # Show specific file
        case "$FILE_TYPE" in
          info|design|impl|tasks|results)
            ST_FILE=$(get_st_path "$ST_ID" "" "$FILE_TYPE.md")
            ;;
          *)
            error "Unknown file type: $FILE_TYPE"
            ;;
        esac
        
        if [ ! -f "$ST_FILE" ]; then
          error "File not found: $FILE_TYPE.md for steel thread $ST_ID"
        fi
        
        cat "$ST_FILE"
      fi
    else
      # Legacy: Show single file
      ST_FILE=$(get_st_path "$ST_ID")
      
      if [ ! -f "$ST_FILE" ]; then
        error "Steel thread not found: $ST_ID"
      fi
      
      cat "$ST_FILE"
    fi
    ;;
    
  "edit")
    # Check for required arguments
    if [ $# -lt 1 ]; then
      error "Steel thread ID is required"
      usage
    fi
    
    # Process the steel thread ID
    ST_ID="$1"
    FILE_TYPE="${2:-info}"  # Default to info
    
    # If just a number is provided, format it as ST#### (with leading zeros)
    if [[ "$ST_ID" =~ ^[0-9]+$ ]]; then
      ST_ID=$(printf "ST%04d" "$ST_ID")
    elif [[ ! "$ST_ID" =~ ^ST ]]; then
      ST_ID="ST$ST_ID"
    fi
    
    if is_directory_structure; then
      # Edit specific file
      case "$FILE_TYPE" in
        info|design|impl|tasks|results)
          ST_FILE=$(get_st_path "$ST_ID" "" "$FILE_TYPE.md")
          ;;
        *)
          error "Unknown file type: $FILE_TYPE"
          ;;
      esac
      
      if [ ! -f "$ST_FILE" ]; then
        # Create the file if it doesn't exist
        ST_DIR=$(dirname "$ST_FILE")
        if [ -d "$ST_DIR" ]; then
          touch "$ST_FILE"
          echo "Created new file: $FILE_TYPE.md"
        else
          error "Steel thread not found: $ST_ID"
        fi
      fi
    else
      # Legacy: Edit single file
      ST_FILE=$(get_st_path "$ST_ID")
      
      if [ ! -f "$ST_FILE" ]; then
        error "Steel thread not found: $ST_ID"
      fi
    fi
    
    # Get absolute path to the file
    ABSOLUTE_PATH=$(cd "$(dirname "$ST_FILE")" && pwd)/$(basename "$ST_FILE")
    
    # Use the appropriate open command based on the OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
      # macOS
      open "$ABSOLUTE_PATH"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
      # Linux
      if command -v xdg-open > /dev/null; then
        xdg-open "$ABSOLUTE_PATH"
      else
        # Fallback to default editor
        ${EDITOR:-vi} "$ABSOLUTE_PATH"
      fi
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
      # Windows
      start "$ABSOLUTE_PATH"
    else
      # Fallback to default editor
      ${EDITOR:-vi} "$ABSOLUTE_PATH"
    fi
    
    echo "Opening steel thread: $ST_ID ($FILE_TYPE.md)"
    ;;
    
  "sync")
    # Parse options
    WRITE_MODE=0
    WIDTH=80
    
    while [ $# -gt 0 ]; do
      case "$1" in
        --write) WRITE_MODE=1; shift ;;
        --width) shift; WIDTH="$1"; shift ;;
        *) error "Unknown option: $1" ;;
      esac
    done
    
    # Paths
    ST_DIR="stp/prj/st"
    INDEX_FILE="$ST_DIR/steel_threads.md"
    
    # Basic validation
    [ ! -d "$ST_DIR" ] && error "Steel threads directory not found"
    [ ! -f "$INDEX_FILE" ] && error "Steel threads index file not found"
    
    if [ $WRITE_MODE -eq 1 ]; then
      # Create temp files
      TMP_FILE=$(mktemp)
      LIST_OUTPUT=$(mktemp)
      
      # Get list output silently
      # Use the actual script path for recursive calls
      SCRIPT_PATH="${BASH_SOURCE[0]}"
      "$SCRIPT_PATH" list --width $WIDTH > "$LIST_OUTPUT" 2>/dev/null
      
      # Extract everything before the markers
      sed -n '1,/<!-- BEGIN: STEEL_THREAD_INDEX -->/p' "$INDEX_FILE" > "$TMP_FILE"
      
      # Add the list output
      cat "$LIST_OUTPUT" >> "$TMP_FILE"
      
      # Add everything after the markers
      sed -n '/<!-- END: STEEL_THREAD_INDEX -->/,$p' "$INDEX_FILE" >> "$TMP_FILE"
      
      # Update file and clean up
      mv "$TMP_FILE" "$INDEX_FILE"
      rm "$LIST_OUTPUT"
      
      echo "Updated steel threads index file: $INDEX_FILE"
    else
      # For display, just run the list command
      SCRIPT_PATH="${BASH_SOURCE[0]}"
      "$SCRIPT_PATH" list --width "$WIDTH"
    fi
    ;;
    
  "organize")
    # Parse options
    WRITE_MODE=0
    while [ $# -gt 0 ]; do
      case "$1" in
        --write)
          WRITE_MODE=1
          shift
          ;;
        *)
          error "Unknown option: $1"
          ;;
      esac
    done
    
    BASE_DIR="stp/prj/st"
    
    # Create required directories if they don't exist
    mkdir -p "$BASE_DIR/COMPLETED" "$BASE_DIR/NOT-STARTED" "$BASE_DIR/CANCELLED"
    
    if is_directory_structure; then
      # Find all steel thread directories in the root directory
      ST_DIRS=$(find "$BASE_DIR" -maxdepth 1 -type d -name "ST[0-9][0-9][0-9][0-9]")
      
      # Process each steel thread directory
      for dir in $ST_DIRS; do
        # Skip if not a directory
        if [ ! -d "$dir" ]; then
          continue
        fi
        
        # Extract ID from directory name
        ID=$(basename "$dir")
        
        # Read status from info.md
        if [ -f "$dir/info.md" ]; then
          YAML_STATUS=$(grep -m 1 "^status:" "$dir/info.md" | sed "s/^status: *//")
          BODY_STATUS=$(grep -m 1 "^\- \*\*Status\*\*:" "$dir/info.md" | sed "s/^\- \*\*Status\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          if [ -n "$YAML_STATUS" ]; then
            STATUS="$YAML_STATUS"
          elif [ -n "$BODY_STATUS" ]; then
            STATUS="$BODY_STATUS"
          else
            STATUS="Not Started"
          fi
          
          echo "Processing directory: $dir"
          echo "  Directory: $ID - Status: $STATUS"
          
          # Get the target location for this directory
          TARGET_DIR=$(dirname $(get_st_path "$ID" "$STATUS" "info.md"))
          
          # If we're in write mode and the target location is different, move the directory
          if [ $WRITE_MODE -eq 1 ] && [ "$dir" != "$TARGET_DIR" ]; then
            mkdir -p "$(dirname "$TARGET_DIR")"
            mv "$dir" "$TARGET_DIR"
            echo "Moving $ID to $(dirname "$TARGET_DIR")"
          else
            if [ "$dir" != "$TARGET_DIR" ]; then
              echo "Would move $ID to $(dirname "$TARGET_DIR")"
            else
              echo "$ID stays in main directory"
            fi
          fi
        fi
      done
      
      # Also check subdirectories
      for subdir in "$BASE_DIR"/*; do
        if [ -d "$subdir" ] && [[ "$subdir" != "$BASE_DIR/steel_threads.md" ]]; then
          SUBDIR_NAME=$(basename "$subdir")
          
          # Find all steel thread directories in this subdirectory
          SUB_ST_DIRS=$(find "$subdir" -maxdepth 1 -type d -name "ST[0-9][0-9][0-9][0-9]")
          
          for dir in $SUB_ST_DIRS; do
            if [ ! -d "$dir" ]; then
              continue
            fi
            
            ID=$(basename "$dir")
            
            if [ -f "$dir/info.md" ]; then
              YAML_STATUS=$(grep -m 1 "^status:" "$dir/info.md" | sed "s/^status: *//")
              BODY_STATUS=$(grep -m 1 "^\- \*\*Status\*\*:" "$dir/info.md" | sed "s/^\- \*\*Status\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              
              if [ -n "$YAML_STATUS" ]; then
                STATUS="$YAML_STATUS"
              elif [ -n "$BODY_STATUS" ]; then
                STATUS="$BODY_STATUS"
              else
                STATUS="Not Started"
              fi
              
              echo "  Processing directory in subdirectory: $dir"
              echo "    Directory: $ID - Status: $STATUS"
              
              TARGET_DIR=$(dirname $(get_st_path "$ID" "$STATUS" "info.md"))
              
              if [ $WRITE_MODE -eq 1 ] && [ "$dir" != "$TARGET_DIR" ]; then
                mkdir -p "$(dirname "$TARGET_DIR")"
                mv "$dir" "$TARGET_DIR"
                echo "Moving $ID from $SUBDIR_NAME to $(basename "$(dirname "$TARGET_DIR")")"
              else
                if [ "$dir" != "$TARGET_DIR" ]; then
                  echo "Would move $ID from $SUBDIR_NAME to $(basename "$(dirname "$TARGET_DIR")")"
                fi
              fi
            fi
          done
        fi
      done
    else
      # Legacy: organize single files (same as original)
      ST_FILES=$(find "$BASE_DIR" -maxdepth 1 -name "ST[0-9][0-9][0-9][0-9].md")
      
      for file in $ST_FILES; do
        if [ ! -f "$file" ]; then
          continue
        fi
        
        ID=$(basename "$file" .md)
        
        YAML_STATUS=$(grep -m 1 "^status:" "$file" | sed "s/^status: *//")
        BODY_STATUS=$(grep -m 1 "^\- \*\*Status\*\*:" "$file" | sed "s/^\- \*\*Status\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        if [ -n "$YAML_STATUS" ]; then
          STATUS="$YAML_STATUS"
        elif [ -n "$BODY_STATUS" ]; then
          STATUS="$BODY_STATUS"
        else
          STATUS="Not Started"
        fi
        
        echo "Processing file: $file"
        echo "  File: $ID - Status: $STATUS"
        
        TARGET_FILE=$(get_st_path "$ID" "$STATUS")
        
        if [ $WRITE_MODE -eq 1 ] && [ "$file" != "$TARGET_FILE" ]; then
          mkdir -p "$(dirname "$TARGET_FILE")"
          mv "$file" "$TARGET_FILE"
          echo "Moving $ID to $(dirname "$TARGET_FILE")"
        else
          if [ "$file" != "$TARGET_FILE" ]; then
            echo "Would move $ID to $(dirname "$TARGET_FILE")"
          else
            echo "$ID stays in main directory"
          fi
        fi
      done
    fi
    
    # If we're in write mode, update the index file after organizing
    if [ $WRITE_MODE -eq 1 ]; then
      SCRIPT_PATH="${BASH_SOURCE[0]}"
      "$SCRIPT_PATH" sync --write
      echo "Updated steel threads index."
    fi
    ;;
    
  "help")
    usage
    ;;
    
  *)
    error "Unknown command: $ST_COMMAND"
    usage
    ;;
esac