#!/bin/bash
# stp_st - Manage steel threads
# Usage: stp_st <command> [options] [arguments]

# Exit on error
set -e

# Function to display error messages
error() {
  echo "Error: $1" >&2
  exit 1
}

# Function to display usage information
usage() {
  echo "Usage: stp st <command> [options] [arguments]"
  echo ""
  echo "Manage steel threads for the project"
  echo ""
  echo "Commands:"
  echo "  new <title>                       Create a new steel thread"
  echo "  done <id>                         Mark a steel thread as complete"
  echo "  list [--status <status>] [--width N] List all steel threads"
  echo "  sync [--write] [--width N]        Synchronize steel_threads.md with individual ST files"
  echo "  show <id>                         Show details of a specific steel thread"
  echo "  edit <id>                         Open a steel thread in your default editor"
  echo ""
  echo "Examples:"
  echo "  stp st new \"Implement Feature X\""
  echo "  stp st done ST0001"
  echo "  stp st list --status \"In Progress\" --width 100"
  echo "  stp st sync --write --width 100"
  echo "  stp st show ST0001"
  echo "  stp st edit 1"
  exit 1
}

# Check for required arguments
if [ $# -lt 1 ]; then
  error "Steel thread command is required"
  usage
fi

# Load project configuration if available
if [ -f stp/.config/config ]; then
  source stp/.config/config
elif [ -f .stp-config ]; then
  # For backward compatibility
  source .stp-config
fi

# Get command
ST_COMMAND="$1"
shift

# Function to get the next steel thread ID
get_next_steel_thread_id() {
  local st_prefix="${ST_PREFIX:-ST}"
  local st_dir="stp/prj/st"
  local next_id=1
  
  # Find the highest existing ID
  if [ -d "$st_dir" ] && [ "$(ls -A "$st_dir" 2>/dev/null)" ]; then
    for file in "$st_dir"/$st_prefix*.md; do
      if [ -f "$file" ]; then
        # Extract numeric part of filename
        local id_str=$(basename "$file" .md)
        id_str=${id_str#$st_prefix}
        
        # Convert to number and compare
        if [[ "$id_str" =~ ^[0-9]+$ ]]; then
          local id=$((10#$id_str))
          if [ $id -ge $next_id ]; then
            next_id=$((id + 1))
          fi
        fi
      fi
    done
  fi
  
  # Format with leading zeros (4 digits)
  printf "%s%04d" "$st_prefix" $next_id
}

# Function to update steel threads index
update_steel_threads_index() {
  local id="$1"
  local title="$2"
  local status="$3"
  local created="$4"
  local completed="$5"
  local index_file="stp/prj/st/steel_threads.md"
  
  # Create index file if it doesn't exist
  if [ ! -f "$index_file" ]; then
    mkdir -p "$(dirname "$index_file")"
    cat > "$index_file" << EOF
# Steel Threads

This document serves as an index of all steel threads in the project.

## Index

| ID | Title | Status | Created | Completed |
|----|-------|--------|---------|-----------|
EOF
  fi
  
  # Check if entry already exists
  if grep -q "^| $id " "$index_file"; then
    # Update existing entry
    sed -i.bak "s/^| $id .*$/| $id | $title | $status | $created | $completed |/" "$index_file"
    rm -f "$index_file.bak"
  else
    # Add new entry
    echo "| $id | $title | $status | $created | $completed |" >> "$index_file"
  fi
}

# Handle different commands
case "$ST_COMMAND" in
  "new")
    # Check for required arguments
    if [ $# -lt 1 ]; then
      error "Steel thread title is required"
      usage
    fi
    
    TITLE="$1"
    ST_ID=$(get_next_steel_thread_id)
    ST_FILE="stp/prj/st/$ST_ID.md"
    DATE=$(date '+%Y-%m-%d')
    AUTHOR="${STP_AUTHOR:-${AUTHOR:-$(git config user.name 2>/dev/null || echo "$USER")}}"
    
    # Create directory if it doesn't exist
    mkdir -p "stp/prj/st"
    
    # Create steel thread file from template
    if [ -f "stp/_templ/prj/st/_ST####.md" ]; then
      # Format date in both formats - YYYY-MM-DD for display and YYYYMMDD for frontmatter
      DATE_COMPACT=$(date '+%Y%m%d')
      
      sed -e "s/ST####/$ST_ID/g" \
          -e "s/\[Title\]/$TITLE/g" \
          -e "s/\[Not Started|In Progress|Completed|On Hold|Cancelled\]/Not Started/g" \
          -e "s/YYYY-MM-DD/$DATE/g" \
          -e "s/YYYYMMDD/$DATE_COMPACT/g" \
          -e "s/\[Author Name\]/$AUTHOR/g" \
          "stp/_templ/prj/st/_ST####.md" > "$ST_FILE"
    else
      # Create file without template
      DATE_COMPACT=$(date '+%Y%m%d')
      cat > "$ST_FILE" << EOF
---
verblock: "$(date '+%d %b %Y'):v0.1: $AUTHOR - Initial version"
stp_version: 1.0.0
status: Not Started
created: $DATE_COMPACT
completed: 
---
# $ST_ID: $TITLE

- **Status**: Not Started
- **Created**: $DATE
- **Completed**: 
- **Author**: $AUTHOR

## Objective
[Clear statement of what this steel thread aims to accomplish]

## Context
[Background information and context for this steel thread]

## Approach
[Planned approach for implementing this steel thread]

## Tasks
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

## Implementation Notes
[Notes on implementation details, decisions, challenges, etc.]

## Results
[Summary of results after completion]

## Related Steel Threads
- [List any related steel threads here]
EOF
    fi
    
    # Update index
    update_steel_threads_index "$ST_ID" "$TITLE" "Not Started" "$DATE" ""
    
    echo "Created steel thread: $ST_ID: $TITLE"
    echo "Edit file: $ST_FILE"
    ;;
    
  "done")
    # Check for required arguments
    if [ $# -lt 1 ]; then
      error "Steel thread ID is required"
      usage
    fi
    
    # Process the steel thread ID
    ST_ID="$1"
    
    # If just a number is provided, format it as ST#### (with leading zeros)
    if [[ "$ST_ID" =~ ^[0-9]+$ ]]; then
      ST_ID=$(printf "ST%04d" "$ST_ID")
    # If the ID doesn't start with ST, prepend it
    elif [[ ! "$ST_ID" =~ ^ST ]]; then
      ST_ID="ST$ST_ID"
    fi
    
    ST_FILE="stp/prj/st/$ST_ID.md"
    DATE=$(date '+%Y-%m-%d')
    
    # Check if steel thread exists
    if [ ! -f "$ST_FILE" ]; then
      error "Steel thread not found: $ST_ID"
    fi
    
    # Extract title
    TITLE=$(grep "^# $ST_ID:" "$ST_FILE" | sed "s/^# $ST_ID: //")
    
    # Update status and completion date
    sed -i.bak "s/^\- \*\*Status\*\*: .*$/- **Status**: Completed/" "$ST_FILE"
    sed -i.bak "s/^\- \*\*Completed\*\*: .*$/- **Completed**: $DATE/" "$ST_FILE"
    rm -f "$ST_FILE.bak"
    
    # Update index
    update_steel_threads_index "$ST_ID" "$TITLE" "Completed" "$(grep '^\- \*\*Created\*\*:' "$ST_FILE" | sed 's/^\- \*\*Created\*\*: //')" "$DATE"
    
    echo "Marked steel thread as complete: $ST_ID: $TITLE"
    ;;
    
  "list")
    # Parse options
    STATUS=""
    WIDTH=0  # Default to terminal width
    while [ $# -gt 0 ]; do
      case "$1" in
        --status)
          shift
          STATUS="$1"
          shift
          ;;
        --width)
          shift
          WIDTH="$1"
          shift
          ;;
        *)
          error "Unknown option: $1"
          ;;
      esac
    done
    
    ST_DIR="stp/prj/st"
    
    # Check if ST directory exists
    if [ ! -d "$ST_DIR" ]; then
      error "Steel threads directory not found"
    fi
    
    # Determine table width
    if [ "$WIDTH" -gt 0 ]; then
      # Use specified width
      TABLE_WIDTH=$WIDTH
    else
      # Use terminal width
      TABLE_WIDTH=$(tput cols 2>/dev/null || echo 80)
    fi
    
    # Set column widths based on terminal width
    ID_WIDTH=10
    STATUS_WIDTH=15
    DATE_WIDTH=10
    
    # Calculate available width for title column (accounting for column separators)
    SEPARATORS_WIDTH=13  # 4 separators at "| " = 8 chars + 5 spaces in header
    FIXED_COLS_WIDTH=$((ID_WIDTH + STATUS_WIDTH + DATE_WIDTH + DATE_WIDTH))
    TITLE_WIDTH=$((TABLE_WIDTH - FIXED_COLS_WIDTH - SEPARATORS_WIDTH))
    
    # Minimum title width - if terminal is too narrow, set a minimum
    [ $TITLE_WIDTH -lt 20 ] && TITLE_WIDTH=20
    
    # Function to truncate string with ellipsis if too long
    truncate_string() {
      local string="$1"
      local width=$2
      
      # Handle empty strings
      if [ -z "$string" ]; then
        echo ""
        return
      fi
      
      # If string length exceeds width, truncate and add ellipsis
      if [ ${#string} -gt $width ]; then
        # For very narrow columns, ensure we at least show something
        if [ $width -le 5 ]; then
          # Just use available width
          echo "${string:0:$width}"
        else
          # Standard truncation with ellipsis
          echo "${string:0:$((width-3))}..."
        fi
      else
        # String fits within width, return as is
        echo "$string"
      fi
    }
    
    # Display steel threads in a formatted table
    printf "%-${ID_WIDTH}s | %-${TITLE_WIDTH}s | %-${STATUS_WIDTH}s | %-${DATE_WIDTH}s | %-${DATE_WIDTH}s\n" \
      "ID" "Title" "Status" "Created" "Completed"
    printf "%-${ID_WIDTH}s-|-%-${TITLE_WIDTH}s-|-%-${STATUS_WIDTH}s-|-%-${DATE_WIDTH}s-|-%-${DATE_WIDTH}s\n" \
      "$(printf '%0.s-' $(seq 1 $ID_WIDTH))" \
      "$(printf '%0.s-' $(seq 1 $TITLE_WIDTH))" \
      "$(printf '%0.s-' $(seq 1 $STATUS_WIDTH))" \
      "$(printf '%0.s-' $(seq 1 $DATE_WIDTH))" \
      "$(printf '%0.s-' $(seq 1 $DATE_WIDTH))"
    
    # Collect data from individual ST files
    declare -a st_data
    
    # Loop through all ST####.md files in the ST directory
    for file in "$ST_DIR"/ST[0-9][0-9][0-9][0-9].md; do
      if [ -f "$file" ]; then
        # Extract ID from filename
        ID=$(basename "$file" .md)
        
        # Extract title from the first line
        TITLE=$(grep "^# $ID:" "$file" | sed "s/^# $ID: //")
        
        # Extract status, created, and completed dates from document body first
        ST_STATUS=$(grep -m 1 "^\- \*\*Status\*\*:" "$file" | sed "s/^\- \*\*Status\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        CREATED=$(grep -m 1 "^\- \*\*Created\*\*:" "$file" | sed "s/^\- \*\*Created\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        COMPLETED=$(grep -m 1 "^\- \*\*Completed\*\*:" "$file" | sed "s/^\- \*\*Completed\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # If empty or not found, try YAML frontmatter
        if [ -z "$ST_STATUS" ] || [ "$ST_STATUS" = "COMPLETED" ]; then
          YAML_STATUS=$(grep -m 1 "^status:" "$file" | sed "s/^status: *//")
          if [ -n "$YAML_STATUS" ]; then
            ST_STATUS="$YAML_STATUS"
          else
            ST_STATUS="Not Started"
          fi
        fi
        
        # If created date is empty or placeholder, try YAML frontmatter
        if [ -z "$CREATED" ] || [ "$CREATED" = "YYYY-MM-DD" ]; then
          YAML_CREATED=$(grep -m 1 "^created:" "$file" | sed "s/^created: *//")
          if [ -n "$YAML_CREATED" ] && [ "$YAML_CREATED" != "YYYYMMDD" ]; then
            # Convert YYYYMMDD to YYYY-MM-DD if needed
            if [[ "$YAML_CREATED" =~ ^[0-9]{8}$ ]]; then
              CREATED="${YAML_CREATED:0:4}-${YAML_CREATED:4:2}-${YAML_CREATED:6:2}"
            else
              CREATED="$YAML_CREATED"
            fi
          else
            CREATED=$(date '+%Y-%m-%d')
          fi
        fi
        
        # If completed date is empty or placeholder, try YAML frontmatter
        if [ -z "$COMPLETED" ] || [ "$COMPLETED" = "YYYY-MM-DD" ]; then
          YAML_COMPLETED=$(grep -m 1 "^completed:" "$file" | sed "s/^completed: *//")
          if [ -n "$YAML_COMPLETED" ] && [ "$YAML_COMPLETED" != "null" ] && [ "$YAML_COMPLETED" != "~" ] && [ "$YAML_COMPLETED" != "YYYYMMDD" ]; then
            # Convert YYYYMMDD to YYYY-MM-DD if needed
            if [[ "$YAML_COMPLETED" =~ ^[0-9]{8}$ ]]; then
              COMPLETED="${YAML_COMPLETED:0:4}-${YAML_COMPLETED:4:2}-${YAML_COMPLETED:6:2}"
            else
              COMPLETED="$YAML_COMPLETED"
            fi
          fi
        fi
        
        # Skip if the requested status doesn't match
        if [ -n "$STATUS" ] && [ "$STATUS" != "$ST_STATUS" ]; then
          continue
        fi
        
        # Add to data array
        st_data+=("$ID|$TITLE|$ST_STATUS|$CREATED|$COMPLETED")
      fi
    done
    
    # Sort by ID in reverse order (newest first)
    IFS=$'\n' sorted_data=($(sort -r <<<"${st_data[*]}"))
    unset IFS
    
    # Process and display rows
    for line in "${sorted_data[@]}"; do
      ID=$(echo "$line" | cut -d'|' -f1)
      TITLE=$(echo "$line" | cut -d'|' -f2)
      ST_STATUS=$(echo "$line" | cut -d'|' -f3)
      CREATED=$(echo "$line" | cut -d'|' -f4)
      COMPLETED=$(echo "$line" | cut -d'|' -f5)
      
      # Truncate values if needed
      ID_TRUNC=$(truncate_string "$ID" $ID_WIDTH)
      TITLE_TRUNC=$(truncate_string "$TITLE" $TITLE_WIDTH)
      STATUS_TRUNC=$(truncate_string "$ST_STATUS" $STATUS_WIDTH)
      CREATED_TRUNC=$(truncate_string "$CREATED" $DATE_WIDTH)
      COMPLETED_TRUNC=$(truncate_string "$COMPLETED" $DATE_WIDTH)
      
      printf "%-${ID_WIDTH}s | %-${TITLE_WIDTH}s | %-${STATUS_WIDTH}s | %-${DATE_WIDTH}s | %-${DATE_WIDTH}s\n" \
        "$ID_TRUNC" "$TITLE_TRUNC" "$STATUS_TRUNC" "$CREATED_TRUNC" "$COMPLETED_TRUNC"
    done
    ;;
    
  "show")
    # Check for required arguments
    if [ $# -lt 1 ]; then
      error "Steel thread ID is required"
      usage
    fi
    
    # Process the steel thread ID
    ST_ID="$1"
    
    # If just a number is provided, format it as ST#### (with leading zeros)
    if [[ "$ST_ID" =~ ^[0-9]+$ ]]; then
      ST_ID=$(printf "ST%04d" "$ST_ID")
    # If the ID doesn't start with ST, prepend it
    elif [[ ! "$ST_ID" =~ ^ST ]]; then
      ST_ID="ST$ST_ID"
    fi
    
    ST_FILE="stp/prj/st/$ST_ID.md"
    
    # Check if steel thread exists
    if [ ! -f "$ST_FILE" ]; then
      error "Steel thread not found: $ST_ID"
    fi
    
    # Display steel thread contents
    cat "$ST_FILE"
    ;;
    
  "edit")
    # Check for required arguments
    if [ $# -lt 1 ]; then
      error "Steel thread ID is required"
      usage
    fi
    
    # Process the steel thread ID
    ST_ID="$1"
    
    # If just a number is provided, format it as ST#### (with leading zeros)
    if [[ "$ST_ID" =~ ^[0-9]+$ ]]; then
      ST_ID=$(printf "ST%04d" "$ST_ID")
    # If the ID doesn't start with ST, prepend it
    elif [[ ! "$ST_ID" =~ ^ST ]]; then
      ST_ID="ST$ST_ID"
    fi
    
    ST_FILE="stp/prj/st/$ST_ID.md"
    
    # Check if steel thread exists
    if [ ! -f "$ST_FILE" ]; then
      error "Steel thread not found: $ST_ID"
    fi
    
    # Get absolute path to the file
    ABSOLUTE_PATH=$(cd "$(dirname "$ST_FILE")" && pwd)/$(basename "$ST_FILE")
    
    # Use the appropriate open command based on the OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
      # macOS
      open "$ABSOLUTE_PATH"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
      # Linux
      if command -v xdg-open > /dev/null; then
        xdg-open "$ABSOLUTE_PATH"
      else
        # Fallback to default editor
        ${EDITOR:-vi} "$ABSOLUTE_PATH"
      fi
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
      # Windows
      start "$ABSOLUTE_PATH"
    else
      # Fallback to default editor
      ${EDITOR:-vi} "$ABSOLUTE_PATH"
    fi
    
    echo "Opening steel thread: $ST_ID"
    ;;
    
  "sync")
    # Parse options
    WRITE_MODE=0
    WIDTH=0  # Default to dynamic width
    while [ $# -gt 0 ]; do
      case "$1" in
        --write)
          WRITE_MODE=1
          shift
          ;;
        --width)
          shift
          WIDTH="$1"
          shift
          ;;
        *)
          error "Unknown option: $1"
          ;;
      esac
    done
    
    ST_DIR="stp/prj/st"
    INDEX_FILE="$ST_DIR/steel_threads.md"
    
    # Check if ST directory exists
    if [ ! -d "$ST_DIR" ]; then
      error "Steel threads directory not found"
    fi
    
    # Check if index file exists
    if [ ! -f "$INDEX_FILE" ]; then
      error "Steel threads index file not found"
    fi
    
    # Temporary file for construction
    TMP_FILE=$(mktemp)
    
    # Copy the original file to the temp file
    cp "$INDEX_FILE" "$TMP_FILE"
    
    # Set column widths
    ID_WIDTH=23  # Wide enough for "[ST0000](./ST0000.md)"
    TITLE_WIDTH=40
    STATUS_WIDTH=12
    DATE_WIDTH=10
    
    # Generate steel thread index content
    ST_INDEX_CONTENT=$(
      # Header row with fixed widths
      printf "| %-${ID_WIDTH}s | %-${TITLE_WIDTH}s | %-${STATUS_WIDTH}s | %-${DATE_WIDTH}s | %-${DATE_WIDTH}s |\n" \
        "ID" "Title" "Status" "Created" "Completed"
      
      # Separator row with proper width
      printf "| %s | %s | %s | %s | %s |\n" \
        "$(printf '%0.s-' $(seq 1 $ID_WIDTH))" \
        "$(printf '%0.s-' $(seq 1 $TITLE_WIDTH))" \
        "$(printf '%0.s-' $(seq 1 $STATUS_WIDTH))" \
        "$(printf '%0.s-' $(seq 1 $DATE_WIDTH))" \
        "$(printf '%0.s-' $(seq 1 $DATE_WIDTH))"
      
      # Loop through all ST####.md files in the ST directory in reverse order (newest first)
      for file in $(find "$ST_DIR" -name "ST[0-9][0-9][0-9][0-9].md" | sort -r); do
        if [ -f "$file" ]; then
          # Extract ID from filename
          ID=$(basename "$file" .md)
          ID_LINK="[$ID](./$ID.md)"
          
          # Extract title from the first line
          TITLE=$(grep "^# $ID:" "$file" | sed "s/^# $ID: //")
          
          # Extract metadata prioritizing document body over YAML frontmatter
          # This ensures we use the actual values that appear in the document body display
          
          # Get status from document body first
          STATUS=$(grep -m 1 "^\- \*\*Status\*\*:" "$file" | sed "s/^\- \*\*Status\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # If empty or not found, try YAML frontmatter
          if [ -z "$STATUS" ]; then
            YAML_STATUS=$(grep -m 1 "^status:" "$file" | sed "s/^status: *//")
            if [ -n "$YAML_STATUS" ]; then
              STATUS="$YAML_STATUS"
            fi
          fi
          
          # Get created date from document body first
          CREATED=$(grep -m 1 "^\- \*\*Created\*\*:" "$file" | sed "s/^\- \*\*Created\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # If empty or not found, try YAML frontmatter
          if [ -z "$CREATED" ] || [ "$CREATED" = "YYYY-MM-DD" ]; then
            YAML_CREATED=$(grep -m 1 "^created:" "$file" | sed "s/^created: *//")
            if [ -n "$YAML_CREATED" ] && [ "$YAML_CREATED" != "YYYYMMDD" ]; then
              # Convert YYYYMMDD to YYYY-MM-DD if needed
              if [[ "$YAML_CREATED" =~ ^[0-9]{8}$ ]]; then
                CREATED="${YAML_CREATED:0:4}-${YAML_CREATED:4:2}-${YAML_CREATED:6:2}"
              else
                CREATED="$YAML_CREATED"
              fi
            fi
          fi
          
          # Get completed date from document body first
          COMPLETED=$(grep -m 1 "^\- \*\*Completed\*\*:" "$file" | sed "s/^\- \*\*Completed\*\*: //" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # If empty or not found, try YAML frontmatter
          if [ -z "$COMPLETED" ] || [ "$COMPLETED" = "YYYY-MM-DD" ]; then
            YAML_COMPLETED=$(grep -m 1 "^completed:" "$file" | sed "s/^completed: *//")
            if [ -n "$YAML_COMPLETED" ] && [ "$YAML_COMPLETED" != "null" ] && [ "$YAML_COMPLETED" != "~" ] && [ "$YAML_COMPLETED" != "YYYYMMDD" ]; then
              # Convert YYYYMMDD to YYYY-MM-DD if needed
              if [[ "$YAML_COMPLETED" =~ ^[0-9]{8}$ ]]; then
                COMPLETED="${YAML_COMPLETED:0:4}-${YAML_COMPLETED:4:2}-${YAML_COMPLETED:6:2}"
              else
                COMPLETED="$YAML_COMPLETED"
              fi
            fi
          fi
          
          # Clean up any placeholder or empty values
          if [ -z "$STATUS" ] || [ "$STATUS" = "COMPLETED" ]; then
            STATUS="Not Started"
          fi
          
          if [ -z "$CREATED" ] || [ "$CREATED" = "YYYYMMDD" ] || [ "$CREATED" = "YYYY-MM-DD" ]; then
            CREATED=$(date '+%Y-%m-%d')
          fi
          
          if [ -z "$COMPLETED" ] || [ "$COMPLETED" = "YYYYMMDD" ] || [ "$COMPLETED" = "YYYY-MM-DD" ]; then
            COMPLETED=""
          fi
          
          # Truncate fields if they exceed maximum width
          if [ ${#TITLE} -gt $TITLE_WIDTH ]; then
            TITLE="${TITLE:0:$((TITLE_WIDTH-3))}..."
          fi
          
          if [ ${#STATUS} -gt $STATUS_WIDTH ]; then
            STATUS="${STATUS:0:$((STATUS_WIDTH-3))}..."
          fi
          
          # Format as markdown table row with proper padding
          printf "| %-${ID_WIDTH}s | %-${TITLE_WIDTH}s | %-${STATUS_WIDTH}s | %-${DATE_WIDTH}s | %-${DATE_WIDTH}s |\n" \
            "$ID_LINK" "$TITLE" "$STATUS" "$CREATED" "$COMPLETED"
        fi
      done
    )
    
    # Update index content between markers
    # Create a temporary file with the replacement content
    SECTION_FILE=$(mktemp)
    {
      echo "<!-- BEGIN: STEEL_THREAD_INDEX -->"
      echo "$ST_INDEX_CONTENT"
      echo "<!-- END: STEEL_THREAD_INDEX -->"
    } > "$SECTION_FILE"
    
    # Replace content between markers using awk
    awk '
      BEGIN { replacing = 0; }
      /<!-- BEGIN: STEEL_THREAD_INDEX -->/ { replacing = 1; system("cat '"$SECTION_FILE"'"); next; }
      /<!-- END: STEEL_THREAD_INDEX -->/ { replacing = 0; next; }
      !replacing { print; }
    ' "$INDEX_FILE" > "$TMP_FILE"
    
    # Clean up temporary file
    rm "$SECTION_FILE"
    
    # If write mode is enabled, update the file
    if [ $WRITE_MODE -eq 1 ]; then
      mv "$TMP_FILE" "$INDEX_FILE"
      echo "Updated steel threads index file: $INDEX_FILE"
    else
      # Otherwise, output to stdout
      cat "$TMP_FILE"
      rm "$TMP_FILE"
    fi
    ;;
    
  "help")
    usage
    ;;
    
  *)
    error "Unknown command: $ST_COMMAND"
    usage
    ;;
esac