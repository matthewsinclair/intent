#!/bin/bash
# stp_upgrade - Upgrade STP files to the latest format
# Usage: stp upgrade [--force]

# Exit on error
set -e

# Current STP version
CURRENT_VERSION="1.2.1"

# Function to display error messages
error() {
  echo "Error: $1" >&2
  exit 1
}

# Function to display usage information
usage() {
  cat << EOF
Usage: stp upgrade [--force] [--organize]

Upgrade STP files to the latest format.

This command scans all STP files and brings them up to date with the latest version.
It adds or updates metadata and ensures all files follow the current format standards.

Options:
  --force     Force upgrade even for major version differences
  --organize  Organize steel thread files into status subdirectories after upgrade

Examples:
  stp upgrade
  stp upgrade --force
  stp upgrade --organize
  stp upgrade --force --organize
EOF
  exit 1
}

# Parse options
FORCE=0
ORGANIZE=0
while [ "$#" -gt 0 ]; do
  case "$1" in
    --force)
      FORCE=1
      shift
      ;;
    --organize)
      ORGANIZE=1
      shift
      ;;
    --help)
      usage
      ;;
    *)
      error "Unknown option: $1"
      ;;
  esac
done

# Load project configuration if available
if [ -f stp/.config/config ]; then
  source stp/.config/config
elif [ -f .stp-config ]; then
  # For backward compatibility
  source .stp-config
fi

echo "Starting STP upgrade process..."
echo "Current STP version: $CURRENT_VERSION"
echo ""

# Function to compare versions
# Returns: 0 if equal, 1 if version1 > version2, 2 if version1 < version2
compare_versions() {
  local version1="$1"
  local version2="$2"
  
  if [ "$version1" = "$version2" ]; then
    return 0
  fi
  
  local IFS=.
  local v1=($version1)
  local v2=($version2)
  
  # Major version comparison
  if [ "${v1[0]:-0}" -gt "${v2[0]:-0}" ]; then
    return 1
  elif [ "${v1[0]:-0}" -lt "${v2[0]:-0}" ]; then
    return 2
  fi
  
  # Minor version comparison
  if [ "${v1[1]:-0}" -gt "${v2[1]:-0}" ]; then
    return 1
  elif [ "${v1[1]:-0}" -lt "${v2[1]:-0}" ]; then
    return 2
  fi
  
  # Patch version comparison
  if [ "${v1[2]:-0}" -gt "${v2[2]:-0}" ]; then
    return 1
  elif [ "${v1[2]:-0}" -lt "${v2[2]:-0}" ]; then
    return 2
  fi
  
  # Equal
  return 0
}

# Function to extract version from a file
get_file_version() {
  local file="$1"
  local version=""
  
  if [ -f "$file" ]; then
    # Try to extract stp_version from YAML frontmatter
    version=$(grep -m 1 "^stp_version:" "$file" | sed "s/^stp_version: *//")
  fi
  
  # If no version found, assume "0.0.0" (pre-versioning)
  if [ -z "$version" ]; then
    version="0.0.0"
  fi
  
  echo "$version"
}

# Function to add/update YAML frontmatter in a file
update_file_frontmatter() {
  local file="$1"
  local temp_file="${file}.tmp"
  
  if [ -f "$file" ]; then
    # Check if file already has YAML frontmatter
    if grep -q "^---" "$file"; then
      # Extract information from the file content for comprehensive frontmatter update
      local title=$(grep -m 1 "^# " "$file" | sed "s/^# //")
      local author=$(grep -m 1 "^\- \*\*Author\*\*:" "$file" | sed "s/^\- \*\*Author\*\*: //")
      local status=$(grep -m 1 "^\- \*\*Status\*\*:" "$file" | sed "s/^\- \*\*Status\*\*: //")
      local created=$(grep -m 1 "^\- \*\*Created\*\*:" "$file" | sed "s/^\- \*\*Created\*\*: //")
      local completed=$(grep -m 1 "^\- \*\*Completed\*\*:" "$file" | sed "s/^\- \*\*Completed\*\*: //")
      
      # Set default values if not found in the file
      if [ -z "$status" ]; then
        status="Not Started"
      fi
      
      if [ -z "$created" ]; then
        created=$(date '+%Y%m%d')
      elif [[ "$created" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        # Convert YYYY-MM-DD to YYYYMMDD if needed
        created=$(echo "$created" | tr -d '-')
      fi
      
      if [ -n "$completed" ] && [ "$completed" != "YYYY-MM-DD" ] && [ ! -z "$(echo "$completed" | tr -d '[:space:]')" ]; then
        if [[ "$completed" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
          # Convert YYYY-MM-DD to YYYYMMDD if needed
          completed=$(echo "$completed" | tr -d '-')
        fi
      else
        completed=""
      fi
      
      if [ -z "$author" ]; then
        author="${STP_AUTHOR:-${AUTHOR:-$(git config user.name 2>/dev/null || echo "$USER")}}"
      fi
      
      # Create a new complete frontmatter with all the necessary fields
      echo "---" > "$temp_file"
      echo "verblock: \"$(date '+%d %b %Y'):v0.1: $author - Updated via STP upgrade\"" >> "$temp_file"
      echo "stp_version: $CURRENT_VERSION" >> "$temp_file"
      echo "status: $status" >> "$temp_file"
      echo "created: $created" >> "$temp_file"
      echo "completed: $completed" >> "$temp_file"
      echo "---" >> "$temp_file"
      
      # Add the rest of the file content, skipping the old frontmatter
      awk '
        BEGIN { in_frontmatter = 0; skip = 0; }
        /^---/ {
          if (in_frontmatter == 0) {
            in_frontmatter = 1;
            skip = 1;
            next;
          } else {
            in_frontmatter = 0;
            skip = 0;
            next;
          }
        }
        !skip { print; }
      ' "$file" >> "$temp_file"
    else
      # Extract information from the file content to create proper frontmatter
      local title=$(grep -m 1 "^# " "$file" | sed "s/^# //")
      local author=$(grep -m 1 "^\- \*\*Author\*\*:" "$file" | sed "s/^\- \*\*Author\*\*: //")
      local status=$(grep -m 1 "^\- \*\*Status\*\*:" "$file" | sed "s/^\- \*\*Status\*\*: //")
      local created=$(grep -m 1 "^\- \*\*Created\*\*:" "$file" | sed "s/^\- \*\*Created\*\*: //")
      local completed=$(grep -m 1 "^\- \*\*Completed\*\*:" "$file" | sed "s/^\- \*\*Completed\*\*: //")
      
      # Set default values if not found in the file
      if [ -z "$status" ]; then
        status="Not Started"
      fi
      
      if [ -z "$created" ]; then
        created=$(date '+%Y%m%d')
      elif [[ "$created" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        # Convert YYYY-MM-DD to YYYYMMDD if needed
        created=$(echo "$created" | tr -d '-')
      fi
      
      if [ -n "$completed" ] && [ "$completed" != "YYYY-MM-DD" ] && [ ! -z "$(echo "$completed" | tr -d '[:space:]')" ]; then
        if [[ "$completed" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
          # Convert YYYY-MM-DD to YYYYMMDD if needed
          completed=$(echo "$completed" | tr -d '-')
        fi
      else
        completed=""
      fi
      
      if [ -z "$author" ]; then
        author="${STP_AUTHOR:-${AUTHOR:-$(git config user.name 2>/dev/null || echo "$USER")}}"
      fi
      
      # Create a new complete frontmatter with all the necessary fields
      echo "---" > "$temp_file"
      echo "verblock: \"$(date '+%d %b %Y'):v0.1: $author - Updated via STP upgrade\"" >> "$temp_file"
      echo "stp_version: $CURRENT_VERSION" >> "$temp_file"
      echo "status: $status" >> "$temp_file"
      echo "created: $created" >> "$temp_file"
      echo "completed: $completed" >> "$temp_file"
      echo "---" >> "$temp_file"
      
      # Add the original file content
      cat "$file" >> "$temp_file"
    fi
    
    # Replace the original file
    mv "$temp_file" "$file"
    echo "Updated: $file"
  fi
}

# Function to upgrade section markers in steel_threads.md
upgrade_section_markers() {
  local file="stp/prj/st/steel_threads.md"
  local temp_file=$(mktemp)
  
  if [ -f "$file" ]; then
    # Check if file already has section markers
    if grep -q "BEGIN: STEEL_THREAD_INDEX" "$file"; then
      echo "Section markers already present in $file"
    else
      # Add section markers
      awk '
        /^## Index/ {
          print;
          print "";
          print "<!-- BEGIN: STEEL_THREAD_INDEX -->";
          in_index = 1;
          next;
        }
        /^##/ && in_index {
          print "<!-- END: STEEL_THREAD_INDEX -->";
          print "";
          in_index = 0;
          print;
          next;
        }
        { print; }
        END {
          if (in_index) {
            print "<!-- END: STEEL_THREAD_INDEX -->";
          }
        }
      ' "$file" > "$temp_file"
      
      # Replace the original file
      mv "$temp_file" "$file"
      echo "Added section markers to $file"
    fi
  fi
}

# Function to split a steel thread file into multiple files
split_steel_thread() {
  local st_file="$1"
  local st_dir="$2"
  local st_id=$(basename "$st_file" .md)
  
  echo "  Migrating $st_id..."
  
  # Create the directory
  mkdir -p "$st_dir"
  
  # Create temporary files for each section
  local temp_info=$(mktemp)
  local temp_design=$(mktemp)
  local temp_impl=$(mktemp)
  local temp_tasks=$(mktemp)
  local temp_results=$(mktemp)
  
  # Track which section we're in
  local current_section="header"
  local has_design=false
  local has_impl=false
  local has_tasks=false
  local has_results=false
  
  # Read the file line by line
  while IFS= read -r line; do
    # Detect section headers
    if [[ "$line" =~ ^##\ Approach ]]; then
      current_section="approach"
      has_design=true
      echo "$line" >> "$temp_design"
    elif [[ "$line" =~ ^##\ Tasks ]]; then
      current_section="tasks"
      has_tasks=true
      echo "$line" >> "$temp_tasks"
    elif [[ "$line" =~ ^##\ Implementation ]]; then
      current_section="implementation"
      has_impl=true
      echo "$line" >> "$temp_impl"
    elif [[ "$line" =~ ^##\ Results ]]; then
      current_section="results"
      has_results=true
      echo "$line" >> "$temp_results"
    elif [[ "$line" =~ ^##\ Related\ Steel\ Threads ]] || [[ "$line" =~ ^##\ Context\ for\ LLM ]]; then
      current_section="footer"
      echo "$line" >> "$temp_info"
    elif [[ "$line" =~ ^##\ (Objective|Context) ]]; then
      current_section="info"
      echo "$line" >> "$temp_info"
    else
      # Write to appropriate file based on current section
      case "$current_section" in
        header|info|footer)
          echo "$line" >> "$temp_info"
          ;;
        approach)
          echo "$line" >> "$temp_design"
          ;;
        tasks)
          echo "$line" >> "$temp_tasks"
          ;;
        implementation)
          echo "$line" >> "$temp_impl"
          ;;
        results)
          echo "$line" >> "$temp_results"
          ;;
      esac
    fi
  done < "$st_file"
  
  # Move temp files to final locations
  mv "$temp_info" "$st_dir/info.md"
  
  # Only create files if they have content
  if [ "$has_design" = true ] && [ -s "$temp_design" ]; then
    # Add header to design.md
    {
      echo "# Design - $st_id: $(grep "^# $st_id:" "$st_file" | sed "s/^# $st_id: //")"
      echo ""
      cat "$temp_design"
    } > "$st_dir/design.md"
  fi
  rm -f "$temp_design"
  
  if [ "$has_impl" = true ] && [ -s "$temp_impl" ]; then
    # Add header to impl.md
    {
      echo "# Implementation - $st_id: $(grep "^# $st_id:" "$st_file" | sed "s/^# $st_id: //")"
      echo ""
      cat "$temp_impl"
    } > "$st_dir/impl.md"
  fi
  rm -f "$temp_impl"
  
  if [ "$has_tasks" = true ] && [ -s "$temp_tasks" ]; then
    # Add header to tasks.md
    {
      echo "# Tasks - $st_id: $(grep "^# $st_id:" "$st_file" | sed "s/^# $st_id: //")"
      echo ""
      cat "$temp_tasks"
    } > "$st_dir/tasks.md"
  fi
  rm -f "$temp_tasks"
  
  if [ "$has_results" = true ] && [ -s "$temp_results" ]; then
    # Add header to results.md
    {
      echo "# Results - $st_id: $(grep "^# $st_id:" "$st_file" | sed "s/^# $st_id: //")"
      echo ""
      cat "$temp_results"
    } > "$st_dir/results.md"
  fi
  rm -f "$temp_results"
  
  # Update stp_version in info.md
  sed -i.bak "s/^stp_version: .*$/stp_version: 1.2.1/" "$st_dir/info.md"
  rm -f "$st_dir/info.md.bak"
  
  echo "    Created: info.md$([ -f "$st_dir/design.md" ] && echo ", design.md")$([ -f "$st_dir/impl.md" ] && echo ", impl.md")$([ -f "$st_dir/tasks.md" ] && echo ", tasks.md")$([ -f "$st_dir/results.md" ] && echo ", results.md")"
}

# Function to migrate steel threads to directory structure
migrate_steel_threads_to_dirs() {
  echo "Migrating steel threads to directory structure (v1.2.0 â†’ v1.2.1)"
  echo ""
  
  # Backup directory
  local BACKUP_DIR=".stp_backup/1.2.1"
  mkdir -p "$BACKUP_DIR"
  
  # Find all steel thread files
  local ST_BASE_DIR="stp/prj/st"
  local ST_FILES=$(find "$ST_BASE_DIR" -name "ST[0-9][0-9][0-9][0-9].md" -type f 2>/dev/null || true)
  
  if [ -z "$ST_FILES" ]; then
    echo "No steel thread files found to migrate."
    return 0
  fi
  
  # Count files
  local FILE_COUNT=$(echo "$ST_FILES" | wc -l | tr -d ' ')
  echo "Found $FILE_COUNT steel thread files to migrate"
  echo ""
  
  # Process each file
  for st_file in $ST_FILES; do
    # Get the base name and directory
    local st_id=$(basename "$st_file" .md)
    local st_parent_dir=$(dirname "$st_file")
    
    # Determine target directory based on current location
    local target_dir
    if [[ "$st_parent_dir" == */COMPLETED ]] || [[ "$st_parent_dir" == */NOT-STARTED ]] || [[ "$st_parent_dir" == */CANCELLED ]]; then
      target_dir="$st_parent_dir/$st_id"
    else
      # In main directory
      target_dir="$st_parent_dir/$st_id"
    fi
    
    # Backup the original file
    local backup_file="$BACKUP_DIR/$(basename "$st_file")"
    cp "$st_file" "$backup_file"
    
    # Split the file into directory structure
    split_steel_thread "$st_file" "$target_dir"
    
    # Remove the original file
    rm "$st_file"
  done
  
  echo ""
  echo "Migration complete!"
  echo "Original files backed up to: $BACKUP_DIR"
  echo ""
  echo "Note: You may want to run 'stp st organize --write' to ensure all"
  echo "steel threads are in the correct status directories."
}

# Scan directories for STP files to upgrade
echo "Scanning for STP files to upgrade..."

# Check for old usage_rules.md file and rename to usage-rules.md
if [ -f "stp/eng/usage_rules.md" ]; then
  echo "Found old usage_rules.md file, renaming to usage-rules.md..."
  mv "stp/eng/usage_rules.md" "stp/eng/usage-rules.md"
  echo "Renamed: stp/eng/usage_rules.md -> stp/eng/usage-rules.md"
fi

# Check for steel threads directory
if [ -d "stp/prj/st" ]; then
  # Check if we need to migrate from files to directories (1.2.0 -> 1.2.1)
  NEEDS_MIGRATION=0
  if ls stp/prj/st/ST*.md 1> /dev/null 2>&1 || ls stp/prj/st/*/ST*.md 1> /dev/null 2>&1; then
    # Check if any .md files exist (old structure)
    for st_file in $(find stp/prj/st -name "ST[0-9][0-9][0-9][0-9].md" -type f 2>/dev/null); do
      NEEDS_MIGRATION=1
      break
    done
  fi
  
  if [ $NEEDS_MIGRATION -eq 1 ]; then
    echo ""
    echo "Detected steel thread files in old format (single files)."
    echo "Migration to directory structure is required for v1.2.1."
    echo ""
    read -p "Migrate steel threads to directory structure? (Y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
      # Run migration function
      migrate_steel_threads_to_dirs
      echo ""
    else
      echo "Migration skipped. Note: Some STP commands may not work correctly with the old format."
      echo ""
    fi
  fi
  
  # Upgrade steel_threads.md
  echo "Checking steel_threads.md..."
  upgrade_section_markers
  
  # Process all steel thread directories (new structure)
  echo "Upgrading steel thread files..."
  if ls stp/prj/st/ST*.md 1> /dev/null 2>&1; then
    for st_file in stp/prj/st/ST*.md; do
    if [ -f "$st_file" ]; then
      file_version=$(get_file_version "$st_file")
      echo "Processing $st_file (current version: $file_version)"
      
      # Check if the file contains the necessary metadata fields
      missing_metadata=0
      if ! grep -q "^\- \*\*Status\*\*:" "$st_file"; then
        echo "  Missing Status field in file"
        missing_metadata=1
      fi
      if ! grep -q "^\- \*\*Created\*\*:" "$st_file"; then
        echo "  Missing Created field in file"
        missing_metadata=1
      fi
      if ! grep -q "^\- \*\*Completed\*\*:" "$st_file"; then
        echo "  Missing Completed field in file"
        missing_metadata=1
      fi
      if ! grep -q "^\- \*\*Author\*\*:" "$st_file"; then
        echo "  Missing Author field in file"
        missing_metadata=1
      fi
      
      # Force update if metadata is missing
      if [ $missing_metadata -eq 1 ]; then
        echo "  Updating file to add missing metadata fields..."
        update_file_frontmatter "$st_file"
        continue
      fi
      
      # Compare versions
      compare_versions "$CURRENT_VERSION" "$file_version"
      comparison=$?
      
      if [ $comparison -eq 0 ]; then
        echo "  Already at latest version, no update needed."
      elif [ $comparison -eq 1 ]; then
        # Current version is newer
        major_current=$(echo $CURRENT_VERSION | cut -d. -f1)
        major_file=$(echo $file_version | cut -d. -f1)
        
        if [ $major_current -gt $major_file ] && [ $FORCE -eq 0 ]; then
          echo "  Warning: File uses major version $major_file, current is $major_current."
          echo "  Use --force to upgrade this file."
        else
          update_file_frontmatter "$st_file"
        fi
      else
        # File version is newer
        echo "  Warning: File version ($file_version) is newer than current version ($CURRENT_VERSION)."
        echo "  This may indicate the file was created with a newer version of STP."
      fi
    fi
    done
  else
    echo "No ST*.md files found in stp/prj/st/ directory"
  fi
  
  # Run the organization command to move files based on status (only if --organize flag is used)
  if [ $ORGANIZE -eq 1 ]; then
    if [ -x "./stp/bin/stp_st" ]; then
      echo ""
      echo "Organizing steel thread files by status..."
      ./stp/bin/stp_st organize --write
    elif [ -n "$STP_HOME" ] && [ -x "$STP_HOME/stp/bin/stp_st" ]; then
      echo ""
      echo "Organizing steel thread files by status..."
      "$STP_HOME/stp/bin/stp_st" organize --write
    fi
  else
    echo ""
    echo "Note: Steel thread files were not reorganized. Use --organize flag to move files to status subdirectories."
  fi
else
  echo "No stp/prj/st directory found. Steel threads upgrade skipped."
fi

echo ""
echo "STP upgrade complete."