defmodule Mix.Tasks.Wdd.Remap do
  @moduledoc """
  Mix task for re-mapping Worker-Bee Driven Design project structure.

  This task allows you to update your project's WDD layer mapping when
  your project structure has evolved or when you want to reorganize
  your WDD layer assignments.

  ## Usage

      mix wdd.remap [options]

  ## Options

    * `--path` - Path to project directory (defaults to current directory)
    * `--backup` - Create backup of existing project map (default: true)
    * `--force` - Skip confirmation prompts
    * `--quiet` - Minimal output

  ## Examples

      # Re-map project structure interactively
      mix wdd.remap

      # Re-map without backup
      mix wdd.remap --no-backup

      # Re-map with no prompts
      mix wdd.remap --force

  ## When to Re-map

  Consider re-mapping when:
  - You've reorganized your project directories
  - You've changed from one project type to another (e.g., library to Phoenix app)
  - You've added new layers or changed layer organization
  - WDD validation suggests your map is outdated
  - You want to adopt different naming conventions

  ## Backup and Recovery

  By default, this task creates a backup of your existing project map:
  - Backup saved as `.wdd_project_map.yaml.backup`
  - Use the backup to restore if needed
  - Backups are timestamped if multiple backups exist

  Generated by Worker-Bee Agent
  """

  use Mix.Task

  alias WorkerBee.ProjectMapper

  @shortdoc "Re-maps Worker-Bee Driven Design project structure"

  @switches [
    path: :string,
    backup: :boolean,
    force: :boolean,
    quiet: :boolean,
    help: :boolean
  ]

  @aliases [
    p: :path,
    f: :force,
    q: :quiet,
    h: :help
  ]

  @impl true
  def run(args) do
    {opts, _} = OptionParser.parse!(args, switches: @switches, aliases: @aliases)

    if opts[:help] do
      show_help()
    else
      remap_project(opts)
    end
  end

  defp remap_project(opts) do
    project_path = opts[:path] || File.cwd!()
    
    unless opts[:quiet] do
      Mix.shell().info("ðŸ”„ Worker-Bee WDD Project Re-mapping")
      Mix.shell().info("=" |> String.duplicate(40))
    end
    
    with :ok <- confirm_remapping(opts),
         :ok <- backup_existing_map(project_path, opts),
         {:ok, project_map} <- perform_discovery(project_path, opts),
         :ok <- save_new_map(project_map, project_path, opts) do
      
      unless opts[:quiet] do
        Mix.shell().info("\nâœ… Project re-mapping completed successfully!")
        display_new_mapping(project_map)
        display_next_steps()
      end
    else
      :cancelled ->
        unless opts[:quiet] do
          Mix.shell().info("Re-mapping cancelled.")
        end
      
      {:error, reason} ->
        Mix.shell().error("âŒ Re-mapping failed: #{reason}")
        System.halt(1)
    end
  end

  defp confirm_remapping(opts) do
    if opts[:force] or opts[:quiet] do
      :ok
    else
      Mix.shell().info("\nâš ï¸  This will replace your current WDD project mapping.")
      
      if Mix.shell().yes?("Continue with re-mapping?") do
        :ok
      else
        :cancelled
      end
    end
  end

  defp backup_existing_map(project_path, opts) do
    map_file = Path.join(project_path, ".wdd_project_map.yaml")
    backup_enabled = Keyword.get(opts, :backup, true)
    
    if File.exists?(map_file) and backup_enabled do
      backup_file = generate_backup_filename(project_path)
      
      case File.copy(map_file, backup_file) do
        {:ok, _} ->
          unless opts[:quiet] do
            Mix.shell().info("ðŸ“¦ Existing map backed up to #{Path.basename(backup_file)}")
          end
          :ok
        
        {:error, reason} ->
          {:error, "Failed to create backup: #{reason}"}
      end
    else
      :ok
    end
  end

  defp generate_backup_filename(project_path) do
    base_backup = Path.join(project_path, ".wdd_project_map.yaml.backup")
    
    if File.exists?(base_backup) do
      timestamp = DateTime.utc_now() |> DateTime.to_unix()
      Path.join(project_path, ".wdd_project_map.yaml.backup.#{timestamp}")
    else
      base_backup
    end
  end

  defp perform_discovery(project_path, opts) do
    unless opts[:quiet] do
      Mix.shell().info("\nðŸ” Starting project structure discovery...")
    end
    
    ProjectMapper.discover_project_structure(project_path)
  end

  defp save_new_map(project_map, project_path, opts) do
    map_file = Path.join(project_path, ".wdd_project_map.yaml")
    
    case ProjectMapper.save_project_map(project_map, map_file) do
      {:ok, _message} ->
        unless opts[:quiet] do
          Mix.shell().info("ðŸ’¾ New project map saved to #{Path.basename(map_file)}")
        end
        :ok
      
      {:error, reason} ->
        {:error, "Failed to save project map: #{reason}"}
    end
  end

  defp display_new_mapping(project_map) do
    Mix.shell().info("\nðŸ“‹ New WDD Layer Mapping:")
    Mix.shell().info("Project: #{project_map.project_name} (#{project_map.project_type})")
    
    Enum.each(project_map.layer_paths, fn {layer, path} ->
      Mix.shell().info("  #{format_layer_name(layer)}: #{path}")
    end)
  end

  defp display_next_steps do
    Mix.shell().info("\nðŸ“‹ Next Steps:")
    Mix.shell().info("  1. Run 'mix wdd.validate' to check compliance with new mapping")
    Mix.shell().info("  2. Use 'mix wdd.scaffold' to generate code following new structure")
    Mix.shell().info("  3. Update existing code to match new layer organization if needed")
    
    Mix.shell().info("\nðŸ’¡ Pro Tip:")
    Mix.shell().info("  Your old mapping is backed up - you can restore it if needed")
  end

  defp format_layer_name(layer) do
    layer
    |> Atom.to_string()
    |> String.capitalize()
    |> String.pad_trailing(10)
  end

  defp show_help do
    Mix.shell().info(@moduledoc)
  end
end