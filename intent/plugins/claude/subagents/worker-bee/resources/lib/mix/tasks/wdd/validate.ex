defmodule Mix.Tasks.Wdd.Validate do
  @moduledoc """
  Mix task for validating Worker-Bee Driven Design compliance.

  This task analyzes your Elixir project against WDD principles and provides
  detailed feedback on compliance issues and recommendations.

  ## Usage

      mix wdd.validate [options]

  ## Options

    * `--path` - Path to project directory (defaults to current directory)
    * `--layer` - Validate specific WDD layer only (data, functions, tests, boundaries, lifecycles, workers)
    * `--file` - Validate specific file only
    * `--output` - Output format: text (default), json, html
    * `--min-score` - Minimum compliance score threshold (0.0-100.0)
    * `--strict` - Treat warnings as errors
    * `--quiet` - Only show violations and summary
    * `--verbose` - Show detailed analysis information
    * `--remap` - Force re-mapping of project structure before validation
    * `--force-discovery` - Alias for --remap

  ## Examples

      # Validate entire project
      mix wdd.validate

      # Validate only functional core layer
      mix wdd.validate --layer functions

      # Validate specific file
      mix wdd.validate --file lib/my_app/core/user_service.ex

      # Generate JSON report
      mix wdd.validate --output json

      # Require minimum 80% compliance score
      mix wdd.validate --min-score 80.0

      # Force re-mapping project structure
      mix wdd.validate --remap

  ## Project Structure Discovery

  This task checks for an existing WDD project map (.wdd_project_map.yaml) first:
  
  - If found, uses the existing mapping (shows "📋 Using existing WDD project map")
  - If not found, guides you through interactive mapping to establish structure
  - Use --remap to force re-discovery even when a map exists
  
  The mapping is saved and reused for future validations unless explicitly re-mapped.

  Generated by Worker-Bee Agent
  """

  use Mix.Task

  alias WorkerBee.{ProjectMapper, WddValidator}

  @shortdoc "Validates Worker-Bee Driven Design compliance"

  @switches [
    path: :string,
    layer: :string,
    file: :string,
    output: :string,
    min_score: :float,
    strict: :boolean,
    quiet: :boolean,
    verbose: :boolean,
    remap: :boolean,
    force_discovery: :boolean,
    help: :boolean
  ]

  @aliases [
    p: :path,
    l: :layer,
    f: :file,
    o: :output,
    m: :min_score,
    s: :strict,
    q: :quiet,
    v: :verbose,
    r: :remap,
    h: :help
  ]

  @impl true
  def run(args) do
    {opts, _} = OptionParser.parse!(args, switches: @switches, aliases: @aliases)

    if opts[:help] do
      show_help()
    else
      validate_project(opts)
    end
  end

  defp validate_project(opts) do
    project_path = opts[:path] || File.cwd!()
    
    Mix.shell().info("🐝 Worker-Bee WDD Validation")
    Mix.shell().info("=" |> String.duplicate(40))
    
    with {:ok, project_map} <- ensure_project_map(project_path, opts),
         {:ok, validation_result} <- run_validation(project_path, project_map, opts),
         :ok <- check_compliance_threshold(validation_result, opts) do
      
      output_results(validation_result, opts)
      
      if has_violations?(validation_result, opts[:strict]) do
        System.halt(1)
      end
    else
      {:error, reason} ->
        Mix.shell().error("❌ Validation failed: #{reason}")
        System.halt(1)
      
      {:compliance_failure, score, threshold} ->
        Mix.shell().error("❌ Compliance score #{score}% below threshold #{threshold}%")
        System.halt(1)
    end
  end

  defp ensure_project_map(project_path, opts \\ []) do
    map_file = Path.join(project_path, ".wdd_project_map.yaml")
    force_remap = opts[:remap] || opts[:force_discovery]
    
    cond do
      force_remap ->
        unless opts[:quiet] do
          Mix.shell().info("🔄 Re-mapping project structure as requested...")
        end
        perform_discovery(project_path, map_file, opts)
      
      File.exists?(map_file) ->
        unless opts[:quiet] do
          Mix.shell().info("📋 Using existing WDD project map")
        end
        ProjectMapper.load_project_map(map_file)
      
      true ->
        unless opts[:quiet] do
          Mix.shell().info("📂 No WDD project map found. Starting discovery session...")
        end
        perform_discovery(project_path, map_file, opts)
    end
  end

  defp perform_discovery(project_path, map_file, opts) do
    case ProjectMapper.discover_project_structure(project_path) do
      {:ok, project_map} ->
        ProjectMapper.save_project_map(project_map, map_file)
        unless opts[:quiet] do
          Mix.shell().info("✅ Project map created at #{map_file}")
        end
        {:ok, project_map}
      
      error ->
        error
    end
  end

  defp run_validation(project_path, project_map, opts) do
    cond do
      opts[:file] ->
        validate_single_file(opts[:file], project_map, opts)
      
      opts[:layer] ->
        validate_layer(project_path, project_map, opts[:layer], opts)
      
      true ->
        validate_entire_project(project_path, project_map, opts)
    end
  end

  defp validate_single_file(file_path, project_map, opts) do
    if not opts[:quiet] do
      Mix.shell().info("🔍 Validating file: #{file_path}")
    end
    
    case File.exists?(file_path) do
      true ->
        result = WddValidator.validate_file(file_path, project_map)
        
        validation_result = %WddValidator{
          project_map: project_map,
          validation_results: [result],
          compliance_score: result.score,
          violations: result.violations,
          recommendations: result.recommendations
        }
        
        {:ok, validation_result}
      
      false ->
        {:error, "File not found: #{file_path}"}
    end
  end

  defp validate_layer(project_path, project_map, layer_name, opts) do
    layer_atom = String.to_existing_atom(layer_name)
    
    if not opts[:quiet] do
      Mix.shell().info("🔍 Validating layer: #{layer_name}")
    end
    
    layer_path = Map.get(project_map.layer_paths, layer_atom)
    
    if layer_path do
      full_layer_path = Path.join(project_path, layer_path)
      
      case validate_directory(full_layer_path, project_map, opts) do
        {:ok, validation_result} -> {:ok, validation_result}
        error -> error
      end
    else
      {:error, "Layer '#{layer_name}' not found in project map"}
    end
  end

  defp validate_entire_project(project_path, project_map, opts) do
    if not opts[:quiet] do
      Mix.shell().info("🔍 Validating entire project...")
    end
    
    WddValidator.validate_project(project_path)
  end

  defp validate_directory(directory_path, project_map, _opts) do
    if File.dir?(directory_path) do
      elixir_files = 
        directory_path
        |> Path.join("**/*.{ex,exs}")
        |> Path.wildcard()
      
      validation_results = Enum.map(elixir_files, fn file_path ->
        WddValidator.validate_file(file_path, project_map)
      end)
      
      compliance_score = calculate_average_score(validation_results)
      violations = Enum.flat_map(validation_results, & &1.violations)
      recommendations = Enum.flat_map(validation_results, & &1.recommendations)
      
      result = %WddValidator{
        project_map: project_map,
        validation_results: validation_results,
        compliance_score: compliance_score,
        violations: violations,
        recommendations: recommendations
      }
      
      {:ok, result}
    else
      {:error, "Directory not found: #{directory_path}"}
    end
  end

  defp check_compliance_threshold(validation_result, opts) do
    case opts[:min_score] do
      nil -> :ok
      threshold when is_float(threshold) ->
        if validation_result.compliance_score >= threshold do
          :ok
        else
          {:compliance_failure, validation_result.compliance_score, threshold}
        end
    end
  end

  defp output_results(validation_result, opts) do
    case opts[:output] do
      "json" -> output_json(validation_result, opts)
      "html" -> output_html(validation_result, opts)
      _ -> output_text(validation_result, opts)
    end
  end

  defp output_text(validation_result, opts) do
    unless opts[:quiet] do
      Mix.shell().info("\n📊 Validation Results")
      Mix.shell().info("=" |> String.duplicate(30))
      
      Mix.shell().info("Files analyzed: #{length(validation_result.validation_results)}")
      Mix.shell().info("Compliance score: #{Float.round(validation_result.compliance_score, 1)}%")
      Mix.shell().info("Total violations: #{length(validation_result.violations)}")
    end
    
    if not Enum.empty?(validation_result.violations) do
      output_violations(validation_result.violations, opts)
    end
    
    if not Enum.empty?(validation_result.recommendations) and not opts[:quiet] do
      output_recommendations(validation_result.recommendations, opts)
    end
    
    output_summary(validation_result, opts)
  end

  defp output_violations(violations, opts) do
    unless opts[:quiet] do
      Mix.shell().info("\n🚨 Violations Found")
      Mix.shell().info("-" |> String.duplicate(20))
    end
    
    violations
    |> Enum.group_by(& &1.severity)
    |> Enum.each(fn {severity, severity_violations} ->
      output_violations_by_severity(severity, severity_violations, opts)
    end)
  end

  defp output_violations_by_severity(severity, violations, opts) do
    severity_icon = case severity do
      :error -> "🔴"
      :warning -> "🟡" 
      :info -> "🔵"
    end
    
    unless opts[:quiet] do
      Mix.shell().info("\n#{severity_icon} #{String.upcase(to_string(severity))} (#{length(violations)})")
    end
    
    violations
    |> Enum.take(if opts[:verbose], do: length(violations), else: 10)
    |> Enum.each(fn violation ->
      location = if violation.line, do: ":#{violation.line}", else: ""
      file_location = "#{violation.file}#{location}"
      
      message = if opts[:verbose] do
        "  #{file_location}\n    #{violation.message}\n    Rule: #{violation.rule}"
      else
        "  #{file_location}: #{violation.message}"
      end
      
      case severity do
        :error -> Mix.shell().error(message)
        :warning -> Mix.shell().info(message)
        :info -> Mix.shell().info(message)
      end
    end)
    
    if not opts[:verbose] and length(violations) > 10 do
      Mix.shell().info("  ... and #{length(violations) - 10} more")
    end
  end

  defp output_recommendations(recommendations, _opts) do
    Mix.shell().info("\n💡 Recommendations")
    Mix.shell().info("-" |> String.duplicate(20))
    
    recommendations
    |> Enum.uniq()
    |> Enum.with_index(1)
    |> Enum.each(fn {recommendation, index} ->
      Mix.shell().info("#{index}. #{recommendation}")
    end)
  end

  defp output_summary(validation_result, opts) do
    score = validation_result.compliance_score
    violations = validation_result.violations
    
    error_count = Enum.count(violations, & &1.severity == :error)
    warning_count = Enum.count(violations, & &1.severity == :warning)
    info_count = Enum.count(violations, & &1.severity == :info)
    
    unless opts[:quiet] do
      Mix.shell().info("\n📋 Summary")
      Mix.shell().info("-" |> String.duplicate(10))
      Mix.shell().info("Compliance Score: #{Float.round(score, 1)}%")
      Mix.shell().info("Errors: #{error_count}")
      Mix.shell().info("Warnings: #{warning_count}")
      Mix.shell().info("Info: #{info_count}")
    end
    
    cond do
      error_count > 0 ->
        Mix.shell().error("\n❌ Validation failed with #{error_count} error(s)")
      
      warning_count > 0 and opts[:strict] ->
        Mix.shell().error("\n❌ Validation failed with #{warning_count} warning(s) (strict mode)")
      
      score >= 90.0 ->
        Mix.shell().info("\n✅ Excellent WDD compliance!")
      
      score >= 75.0 ->
        Mix.shell().info("\n✅ Good WDD compliance")
      
      score >= 50.0 ->
        Mix.shell().info("\n⚠️  Moderate WDD compliance - consider improvements")
      
      true ->
        Mix.shell().error("\n❌ Poor WDD compliance - refactoring recommended")
    end
  end

  defp output_json(validation_result, _opts) do
    json_output = %{
      compliance_score: validation_result.compliance_score,
      files_analyzed: length(validation_result.validation_results),
      total_violations: length(validation_result.violations),
      violations_by_severity: count_violations_by_severity(validation_result.violations),
      violations: format_violations_for_json(validation_result.violations),
      recommendations: validation_result.recommendations,
      summary: generate_summary_text(validation_result)
    }
    
    Mix.shell().info(Jason.encode!(json_output, pretty: true))
  end

  defp output_html(_validation_result, _opts) do
    Mix.shell().info("HTML output not yet implemented")
  end

  defp has_violations?(validation_result, strict_mode) do
    violations = validation_result.violations
    
    error_count = Enum.count(violations, & &1.severity == :error)
    warning_count = Enum.count(violations, & &1.severity == :warning)
    
    error_count > 0 or (strict_mode and warning_count > 0)
  end

  defp calculate_average_score(validation_results) do
    if Enum.empty?(validation_results) do
      0.0
    else
      total_score = Enum.reduce(validation_results, 0.0, fn result, acc ->
        acc + result.score
      end)
      
      total_score / length(validation_results)
    end
  end

  defp count_violations_by_severity(violations) do
    violations
    |> Enum.group_by(& &1.severity)
    |> Map.new(fn {severity, violations_list} ->
      {severity, length(violations_list)}
    end)
  end

  defp format_violations_for_json(violations) do
    Enum.map(violations, fn violation ->
      %{
        type: violation.type,
        severity: violation.severity,
        file: violation.file,
        line: violation.line,
        message: violation.message,
        rule: violation.rule
      }
    end)
  end

  defp generate_summary_text(validation_result) do
    score = validation_result.compliance_score
    
    cond do
      score >= 90.0 -> "Excellent WDD compliance"
      score >= 75.0 -> "Good WDD compliance"
      score >= 50.0 -> "Moderate WDD compliance"
      true -> "Poor WDD compliance"
    end
  end

  defp show_help do
    Mix.shell().info(@moduledoc)
  end
end