defmodule Mix.Tasks.Wdd.Scaffold do
  @moduledoc """
  Mix task for scaffolding Worker-Bee Driven Design compliant modules.

  This task generates WDD-compliant Elixir modules based on your project's
  established structure and conventions. It creates properly organized code
  following the 6-layer WDD architecture.

  ## Usage

      mix wdd.scaffold TYPE NAME [options]

  ## Types

    * `functional` - Generate functional core module
    * `boundary` - Generate boundary layer (GenServer + API)
    * `data` - Generate data structure module
    * `worker` - Generate worker process
    * `supervisor` - Generate supervisor module
    * `component` - Generate complete WDD component (all layers)

  ## Options

    * `--path` - Target project directory (defaults to current directory)
    * `--module-prefix` - Override module prefix from project map
    * `--no-tests` - Skip test file generation
    * `--no-docs` - Skip documentation generation
    * `--dry-run` - Show what would be generated without creating files
    * `--force` - Overwrite existing files
    * `--quiet` - Minimal output
    * `--remap` - Force re-mapping of project structure before scaffolding
    * `--force-discovery` - Alias for --remap

  ## Examples

      # Generate functional core module
      mix wdd.scaffold functional UserService

      # Generate complete WDD component
      mix wdd.scaffold component UserManagement

      # Generate boundary layer with custom options
      mix wdd.scaffold boundary PaymentProcessor --force

      # Generate data structure
      mix wdd.scaffold data User

      # Dry run to see what would be generated
      mix wdd.scaffold component OrderProcessing --dry-run

  ## Project Structure Discovery

  This task checks for an existing WDD project map (.wdd_project_map.yaml) first:
  
  - If found, uses the existing mapping for scaffolding
  - If not found, guides you through interactive mapping to establish structure
  - Use --remap to force re-discovery even when a map exists
  
  Generated code follows the established project structure and conventions.

  ## Component Types Details

  ### functional
  Creates a pure functional core module with:
  - Business logic functions
  - Type specifications
  - Documentation
  - Pure function patterns
  - Corresponding tests

  ### boundary  
  Creates boundary layer modules with:
  - GenServer for state management
  - API module for clean interface
  - Error handling with 'with' statements
  - Integration tests

  ### data
  Creates data structure module with:
  - Struct definition with defaults
  - Constructor and update functions
  - Validation functions
  - Type specifications

  ### worker
  Creates worker process with:
  - Background job processing
  - Queue management
  - Concurrent work handling
  - OTP compliance

  ### supervisor
  Creates supervisor module with:
  - Child process management
  - Restart strategies
  - Dynamic child handling

  ### component
  Creates complete WDD component with:
  - Data layer (structs, types)
  - Functional core (business logic)
  - Boundary layer (GenServer + API)
  - Comprehensive tests
  - All properly organized in WDD layers

  Generated by Worker-Bee Agent
  """

  use Mix.Task

  alias WorkerBee.{ProjectMapper, TemplateGenerator}

  @shortdoc "Scaffolds Worker-Bee Driven Design compliant modules"

  @component_types ~w(functional boundary data worker supervisor component)

  @switches [
    path: :string,
    module_prefix: :string,
    no_tests: :boolean,
    no_docs: :boolean,
    dry_run: :boolean,
    force: :boolean,
    quiet: :boolean,
    remap: :boolean,
    force_discovery: :boolean,
    help: :boolean
  ]

  @aliases [
    p: :path,
    m: :module_prefix,
    d: :dry_run,
    f: :force,
    q: :quiet,
    r: :remap,
    h: :help
  ]

  @impl true
  def run([]) do
    show_help()
  end

  @impl true
  def run(args) do
    {opts, args} = OptionParser.parse!(args, switches: @switches, aliases: @aliases)

    if opts[:help] do
      show_help()
    else
      case args do
        [type, name | _] when type in @component_types ->
          scaffold_component(type, name, opts)
        
        [type, _name | _] ->
          Mix.shell().error("âŒ Unknown component type: #{type}")
          Mix.shell().info("Available types: #{Enum.join(@component_types, ", ")}")
          System.halt(1)
        
        [type] when type in @component_types ->
          Mix.shell().error("âŒ Component name required")
          Mix.shell().info("Usage: mix wdd.scaffold #{type} MyComponentName")
          System.halt(1)
        
        _ ->
          show_help()
          System.halt(1)
      end
    end
  end

  defp scaffold_component(type, name, opts) do
    project_path = opts[:path] || File.cwd!()
    
    unless opts[:quiet] do
      Mix.shell().info("ðŸ Worker-Bee WDD Scaffolding")
      Mix.shell().info("=" |> String.duplicate(35))
      Mix.shell().info("Type: #{type}")
      Mix.shell().info("Name: #{name}")
    end
    
    with {:ok, project_map} <- ensure_project_map(project_path, opts),
         {:ok, generated_files} <- generate_component(type, name, project_map, opts),
         :ok <- create_files(generated_files, opts) do
      
      unless opts[:quiet] do
        Mix.shell().info("\nâœ… Scaffolding completed successfully!")
        Mix.shell().info("Generated #{length(generated_files)} file(s):")
        
        Enum.each(generated_files, fn file_path ->
          Mix.shell().info("  â€¢ #{file_path}")
        end)
        
        display_next_steps(type, name, opts)
      end
    else
      {:error, reason} ->
        Mix.shell().error("âŒ Scaffolding failed: #{reason}")
        System.halt(1)
    end
  end

  defp ensure_project_map(project_path, opts) do
    map_file = Path.join(project_path, ".wdd_project_map.yaml")
    force_remap = opts[:remap] || opts[:force_discovery]
    
    cond do
      force_remap ->
        unless opts[:quiet] do
          Mix.shell().info("ðŸ”„ Re-mapping project structure as requested...")
        end
        perform_discovery(project_path, map_file, opts)
      
      File.exists?(map_file) ->
        unless opts[:quiet] do
          Mix.shell().info("ðŸ“‹ Using existing WDD project map")
        end
        ProjectMapper.load_project_map(map_file)
      
      true ->
        unless opts[:quiet] do
          Mix.shell().info("ðŸ“‚ No WDD project map found. Starting discovery session...")
        end
        perform_discovery(project_path, map_file, opts)
    end
  end

  defp perform_discovery(project_path, map_file, opts) do
    case ProjectMapper.discover_project_structure(project_path) do
      {:ok, project_map} ->
        ProjectMapper.save_project_map(project_map, map_file)
        unless opts[:quiet] do
          Mix.shell().info("âœ… Project map created at #{map_file}")
        end
        {:ok, project_map}
      
      error ->
        error
    end
  end

  defp generate_component(type, name, project_map, opts) do
    component_type = String.to_atom(type)
    options = build_generation_options(opts)
    
    case TemplateGenerator.scaffold_component(".", name, component_type, options) do
      {:ok, file_paths} -> {:ok, file_paths}
      {:error, reason} -> {:error, reason}
    end
  end

  defp build_generation_options(opts) do
    options = %{}
    
    options = if opts[:module_prefix] do
      Map.put(options, :module_prefix, opts[:module_prefix])
    else
      options
    end
    
    options = Map.put(options, :with_tests, not opts[:no_tests])
    options = Map.put(options, :with_docs, not opts[:no_docs])
    
    options
  end

  defp create_files(file_paths, opts) do
    cond do
      opts[:dry_run] ->
        display_dry_run_results(file_paths, opts)
        :ok
      
      true ->
        create_actual_files(file_paths, opts)
    end
  end

  defp display_dry_run_results(file_paths, opts) do
    unless opts[:quiet] do
      Mix.shell().info("\nðŸ” Dry Run - Files that would be generated:")
      
      Enum.each(file_paths, fn file_path ->
        status = if File.exists?(file_path) do
          "ðŸ“ [OVERWRITE]"
        else
          "ðŸ“„ [NEW]"
        end
        
        Mix.shell().info("  #{status} #{file_path}")
      end)
      
      Mix.shell().info("\nRun without --dry-run to create these files.")
    end
  end

  defp create_actual_files(file_paths, opts) do
    conflicts = check_for_conflicts(file_paths, opts[:force])
    
    case conflicts do
      [] ->
        write_files(file_paths, opts)
        :ok
      
      conflict_files ->
        handle_conflicts(conflict_files, opts)
    end
  end

  defp check_for_conflicts(file_paths, force?) do
    if force? do
      []
    else
      Enum.filter(file_paths, &File.exists?/1)
    end
  end

  defp handle_conflicts(conflict_files, opts) do
    unless opts[:quiet] do
      Mix.shell().error("\nâš ï¸  File conflicts detected:")
      Enum.each(conflict_files, fn file ->
        Mix.shell().error("  â€¢ #{file}")
      end)
      Mix.shell().info("\nUse --force to overwrite existing files")
    end
    
    {:error, "File conflicts detected. Use --force to overwrite."}
  end

  defp write_files(file_paths, opts) do
    unless opts[:quiet] do
      Mix.shell().info("\nðŸ“ Creating files...")
    end
    
    Enum.each(file_paths, fn file_path ->
      File.mkdir_p!(Path.dirname(file_path))
      unless opts[:quiet] do
        Mix.shell().info("  âœ“ #{file_path}")
      end
    end)
  end

  defp display_next_steps(type, name, opts) do
    unless opts[:quiet] do
      Mix.shell().info("\nðŸ“‹ Next Steps:")
      
      case type do
        "functional" ->
          Mix.shell().info("  1. Implement business logic in #{name}")
          Mix.shell().info("  2. Add type specifications")
          Mix.shell().info("  3. Run tests: mix test")
          Mix.shell().info("  4. Validate WDD compliance: mix wdd.validate")
        
        "boundary" ->
          Mix.shell().info("  1. Define GenServer state and callbacks")
          Mix.shell().info("  2. Implement API functions")
          Mix.shell().info("  3. Add to supervision tree")
          Mix.shell().info("  4. Run integration tests")
          Mix.shell().info("  5. Validate WDD compliance: mix wdd.validate")
        
        "data" ->
          Mix.shell().info("  1. Define struct fields and defaults")
          Mix.shell().info("  2. Implement validation functions")
          Mix.shell().info("  3. Add type specifications")
          Mix.shell().info("  4. Run tests: mix test")
        
        "worker" ->
          Mix.shell().info("  1. Implement work processing logic")
          Mix.shell().info("  2. Add to supervision tree")
          Mix.shell().info("  3. Configure job queue")
          Mix.shell().info("  4. Test concurrent processing")
        
        "supervisor" ->
          Mix.shell().info("  1. Define child specifications")
          Mix.shell().info("  2. Configure restart strategies")
          Mix.shell().info("  3. Add to application supervision tree")
          Mix.shell().info("  4. Test failure scenarios")
        
        "component" ->
          Mix.shell().info("  1. Implement data structures")
          Mix.shell().info("  2. Add business logic to functional core")
          Mix.shell().info("  3. Configure boundary layer")
          Mix.shell().info("  4. Add to supervision tree")
          Mix.shell().info("  5. Run full test suite")
          Mix.shell().info("  6. Validate WDD compliance: mix wdd.validate")
      end
      
      Mix.shell().info("\nðŸ’¡ Pro Tips:")
      Mix.shell().info("  â€¢ Use 'mix wdd.validate' to check compliance")
      Mix.shell().info("  â€¢ Follow Railway-Oriented Programming patterns")
      Mix.shell().info("  â€¢ Keep functional core pure (no side effects)")
      Mix.shell().info("  â€¢ Test behavior, not implementation")
    end
  end

  defp show_help do
    Mix.shell().info(@moduledoc)
  end
end