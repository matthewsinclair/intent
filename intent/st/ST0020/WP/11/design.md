# Design - WP-11: Diogenes Test Architect Subagent + intent-elixir-testing Skill

## Problem Statement

Claude Code writes tests that look correct but fail to catch real bugs:

1. **Shape tests** -- assert `is_struct`, `is_map`, `refute is_nil` instead of checking concrete values
2. **Control flow in tests** -- `case/if/cond` in test bodies hides failures when the wrong branch executes
3. **Stub coupling** -- tests pass because the implementation is a fake that returns the expected shape
4. **Weak error checks** -- `{:error, _}` matches any error, not the specific one the code should return

Root cause: most training data contains mediocre tests. The AI has learned to produce tests that satisfy coverage metrics but not correctness.

## Solution Architecture

### Two-Part Approach

| Component             | Type     | When Active      | Purpose                                |
| --------------------- | -------- | ---------------- | -------------------------------------- |
| Diogenes subagent     | Subagent | On-demand (Task) | Deep analysis, spec generation, review |
| intent-elixir-testing | Skill    | Always-on        | Real-time enforcement of test quality  |

The skill prevents bad patterns as code is written. The subagent provides deeper analysis when needed -- producing formal specifications that the skill then enforces.

### Inspiration

The approach mirrors the successful `socrates` subagent (CTO Review Mode), which uses a two-persona Socratic dialog to explore technical decisions. Diogenes applies the same methodology to testing: structured conversation between personas reveals gaps that a single perspective misses.

## Diogenes Subagent Design

### Two Personas

**Aristotle (The Empiricist)**

- Methodical, systematic, taxonomic
- Asks: "What must be observably true?"
- Focuses on: domain contracts, invariants, observable outcomes
- Role: defines what should be tested

**Diogenes (The Skeptic)**

- Provocative, cynical, relentless
- Asks: "Would this test catch a broken implementation?"
- Exposes: shape tests, weak assertions, hidden coupling, stub-friendly tests
- Role: challenges every proposed assertion until only strong ones survive

### Two Modes

#### Specify Mode (5 Phases)

**Phase 1 -- Intent Discovery** (Aristotle leads)

- Read the module under test
- Identify domain purpose (WHY this module exists)
- Enumerate public contract (each public function's role)
- Note dependencies and side effects

**Phase 2 -- Outcome Definition** (Both personas)

- For each public function, define:
  - Success outcomes (happy path returns)
  - Failure outcomes (specific errors and conditions)
  - Invariants (always-true properties)
  - Side effects (observable external effects)

**Phase 3 -- Challenge** (Diogenes leads)

- For each assertion: "Is this strong enough?"
- "What if the function returned a hardcoded struct?"
- "You're checking `is_struct` -- that's a shape test. What field values prove correctness?"
- "This error check matches `{:error, _}` -- what if it's the wrong error?"

**Phase 4 -- Specification** (Aristotle writes, Diogenes reviews)

- Produce the formal test spec in template format
- Each assertion must survive Diogenes' scrutiny

**Phase 5 -- Conclusion**

- Write spec to `test/<path>/<module>_test.spec.md`
- Summary: N functions, M assertions, K edge cases

#### Validate Mode

Input: a spec file + corresponding test file
Output: gap analysis

Checks:

- Every spec assertion has a corresponding ExUnit test
- No test body contains control flow (if/case/cond/||/&&)
- All assertions check concrete values (not shapes)
- Test names match spec assertion names exactly
- No unnecessary mocking -- real code used wherever possible
- Common patterns extracted into shared helpers

### Test Spec Template

```markdown
# Test Specification: MyApp.Accounts

Generated by Diogenes on YYYY-MM-DD
Source: lib/my_app/accounts.ex

## Module Intent

[1-3 sentences: what domain problem does this module solve?]

## Public Contract

| Function        | Purpose                 | Returns                           |
| --------------- | ----------------------- | --------------------------------- |
| register_user/2 | Create new user account | {:ok, User} / {:error, changeset} |

## Test Assertions

### register_user/2

- success: creates user with valid email and password
  - assert user.email == input_email
  - assert user.hashed_password != input_password

- failure: rejects duplicate email
  - setup: create user with email "taken@example.com"
  - assert {:error, changeset} returned
  - assert "has already been taken" in errors_on(changeset).email

- invariant: plaintext password never persisted
  - create user, reload from database
  - assert reloaded_user.password == nil

## Diogenes Notes

[Skeptic's observations about remaining risks]
```

## intent-elixir-testing Skill Design

### 8 Rules

1. **No control flow in test bodies** -- setup, action, assert only
2. **Strong assertions against concrete values** -- no shape-only checks
3. **One assertion focus per test** -- success:/failure:/invariant: prefix
4. **Test the domain contract, not the implementation** -- public API only
5. **Real code over mocks** -- mock only at true external boundaries
6. **The Highlander Rule for tests** -- no duplicated setup/patterns
7. **Globally unique test data** -- `System.unique_integer/1` for identity attrs
8. **Spec-driven tests when spec exists** -- tests must match spec assertions

Each rule includes BAD/GOOD Elixir code examples.

### Relationship to Existing Artifacts

- Complements `testing.md` reference doc (WP-05) -- the reference doc describes patterns, the skill enforces them
- Complements `intent-elixir-essentials` skill -- that skill covers general Elixir, this covers testing specifically
- Diogenes references `testing.md` for DataCase/ConnCase/Mox patterns

## Key Design Decisions

| Decision                                 | Choice                  | Rationale                                                                   |
| ---------------------------------------- | ----------------------- | --------------------------------------------------------------------------- |
| Standalone subagent vs. elixir extension | Standalone `diogenes`   | Testing architect is a distinct role; keeps elixir subagent focused on code |
| Persona names                            | Aristotle + Diogenes    | Aristotle = empirical observation; Diogenes = cynical truth-seeking         |
| Spec file location                       | Next to test file       | Easy to find; `.spec.md` extension distinguishes from test code             |
| Rule count for skill                     | 8 rules                 | Consistent with other Elixir skills (7-8 rules each)                        |
| Skill name                               | `intent-elixir-testing` | Follows `intent-elixir-*` namespace convention                              |

## Alternatives Considered

1. **Extend existing elixir subagent** -- Rejected: would bloat the elixir agent, testing architect is a distinct role
2. **Single-persona analysis** -- Rejected: the dialog format catches gaps that a single perspective misses (proven by socrates subagent)
3. **Credo-based enforcement** -- Rejected: Credo catches syntax patterns but not semantic issues like shape tests
4. **Fewer skill rules** -- Rejected: each rule addresses a distinct failure mode observed in practice
