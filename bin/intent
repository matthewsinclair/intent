#!/bin/bash
# intent - Main command for Intent
# Copyright (c) 2026 Matthew Sinclair
# Licensed under the MIT License (see LICENSE file)
# Usage: intent <command> [options] [arguments]

# Exit on error
set -e

# Determine INTENT_HOME early for version loading
if [ -z "$INTENT_HOME" ]; then
  INTENT_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
fi

# Source helpers for version function
if [ -f "$INTENT_HOME/bin/intent_helpers" ]; then
  source "$INTENT_HOME/bin/intent_helpers"
fi

# Get version from centralized source
INTENT_VERSION="$(get_intent_version 2>/dev/null || echo "2.2.1")"

# Function to display error messages
error() {
  echo "Error: $1" >&2
  exit 1
}

# Export INTENT_HOME
export INTENT_HOME

# Check if bin directory exists
if [ ! -d "$INTENT_HOME/bin" ]; then
  error "Invalid INTENT_HOME: bin directory not found at $INTENT_HOME/bin"
fi

# Set bin directory
BIN_DIR="$INTENT_HOME/bin"

# Define global commands that don't require project context
GLOBAL_COMMANDS="help doctor bootstrap init version info fileindex upgrade"

# Function to check if command is global
is_global_command() {
  local cmd="$1"
  for gc in $GLOBAL_COMMANDS; do
    [ "$cmd" = "$gc" ] && return 0
  done
  return 1
}

# Display info if no arguments provided
if [ $# -eq 0 ]; then
  # Info is a global command, execute directly
  exec "$BIN_DIR/intent_info"
fi

# Get the command
COMMAND="$1"
shift

# Handle version flag
if [ "$COMMAND" = "--version" ] || [ "$COMMAND" = "-v" ] || [ "$COMMAND" = "version" ]; then
  echo "Intent version $INTENT_VERSION"
  exit 0
fi

# Handle help command specially
if [ "$COMMAND" = "help" ] || [ "$COMMAND" = "--help" ] || [ "$COMMAND" = "-h" ]; then
  exec "$BIN_DIR/intent_help" "$@"
fi

# Handle plugin commands
PLUGIN_COMMAND=""
PLUGIN_SUBCOMMAND=""

# Check for plugin commands (claude, agents)
case "$COMMAND" in
  claude)
    # Claude plugin - check for subcommand
    if [ $# -ge 1 ] && [ "$1" = "subagents" ]; then
      PLUGIN_COMMAND="claude"
      PLUGIN_SUBCOMMAND="subagents"
      shift  # Remove 'subagents' from arguments
      COMMAND_SCRIPT="$INTENT_HOME/intent/plugins/claude/bin/intent_claude_subagents"
    elif [ $# -ge 1 ] && [ "$1" = "skills" ]; then
      PLUGIN_COMMAND="claude"
      PLUGIN_SUBCOMMAND="skills"
      shift  # Remove 'skills' from arguments
      COMMAND_SCRIPT="$INTENT_HOME/intent/plugins/claude/bin/intent_claude_skills"
    elif [ $# -ge 1 ] && [ "$1" = "upgrade" ]; then
      PLUGIN_COMMAND="claude"
      PLUGIN_SUBCOMMAND="upgrade"
      shift  # Remove 'upgrade' from arguments
      COMMAND_SCRIPT="$INTENT_HOME/intent/plugins/claude/bin/intent_claude_upgrade"
    else
      error "Unknown claude subcommand. Try: intent claude subagents, intent claude skills, intent claude upgrade"
    fi
    ;;
  agents)
    # AGENTS.md plugin
    PLUGIN_COMMAND="agents"
    COMMAND_SCRIPT="$INTENT_HOME/intent/plugins/agents/bin/intent_agents"
    ;;
  st)
    COMMAND="st"
    COMMAND_SCRIPT="intent_st"
    ;;
  bl)
    COMMAND="bl"
    COMMAND_SCRIPT="intent_bl"
    ;;
  *)
    # Default: prefix with intent_
    COMMAND_SCRIPT="intent_$COMMAND"
    ;;
esac

# Check if command script exists
if [ -n "$PLUGIN_COMMAND" ]; then
  # For plugin commands, check plugin path
  if [ ! -f "$COMMAND_SCRIPT" ]; then
    error "Plugin command not found: $COMMAND_SCRIPT"
  fi
else
  # For regular commands, check bin directory
  if [ ! -f "$BIN_DIR/$COMMAND_SCRIPT" ]; then
    error "Unknown command '$COMMAND'. Run 'intent help' for usage information."
  fi
fi

# Check if script is executable
if [ -n "$PLUGIN_COMMAND" ]; then
  # For plugin commands
  if [ ! -x "$COMMAND_SCRIPT" ]; then
    echo "Warning: Making plugin script executable: $COMMAND_SCRIPT" >&2
    chmod +x "$COMMAND_SCRIPT"
  fi
else
  # For regular commands
  if [ ! -x "$BIN_DIR/$COMMAND_SCRIPT" ]; then
    echo "Warning: Making script executable: $COMMAND_SCRIPT" >&2
    chmod +x "$BIN_DIR/$COMMAND_SCRIPT"
  fi
fi

# Check if this is a global command or plugin command
if [ -n "$PLUGIN_COMMAND" ]; then
  # Plugin commands may have their own context requirements
  # Let the plugin handle it
  exec "$COMMAND_SCRIPT" "$@"
elif is_global_command "$COMMAND"; then
  # Execute without requiring project context
  exec "$BIN_DIR/$COMMAND_SCRIPT" "$@"
fi

# For project commands, source config and check for project root
if [ -f "$BIN_DIR/intent_config" ]; then
  source "$BIN_DIR/intent_config"
  # Load configuration
  load_intent_config
  
  # Check if we found a project root (check for empty or unset)
  if [ -z "${PROJECT_ROOT:-}" ] || [ "$PROJECT_ROOT" = "" ]; then
    echo "Error: Not in an Intent project directory." >&2
    echo "" >&2
    echo "The '$COMMAND' command requires an Intent project." >&2
    echo "" >&2
    echo "To create a new project:  intent init" >&2
    echo "To see all commands:      intent help" >&2
    exit 1
  fi
else
  error "Missing intent_config library. Intent installation may be corrupted."
fi

# Execute command with remaining arguments
if [ -n "$PLUGIN_COMMAND" ]; then
  exec "$COMMAND_SCRIPT" "$@"
else
  exec "$BIN_DIR/$COMMAND_SCRIPT" "$@"
fi