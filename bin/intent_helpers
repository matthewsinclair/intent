#!/bin/bash
# intent_helpers - Shared functions for Intent migration and utilities

# ---- Core Shared Helpers ----

# Display an error message and exit
error() {
  echo "Error: $1" >&2
  exit 1
}
export -f error

# Get Intent version from VERSION file
get_intent_version() {
  local version_file="${INTENT_HOME:-$(dirname "${BASH_SOURCE[0]}")/..}/VERSION"

  if [ -f "$version_file" ]; then
    cat "$version_file"
  else
    # Fallback version if VERSION file doesn't exist
    echo "2.2.1"
  fi
}
export -f get_intent_version

# Calculate SHA256 checksum for a file
calculate_checksum() {
  local file="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$file" | cut -d' ' -f1
  elif command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$file" | cut -d' ' -f1
  else
    echo "unknown"
  fi
}
export -f calculate_checksum

# Get terminal width with fallback chain
get_terminal_width() {
  local width="${COLUMNS:-}"
  if [ -z "$width" ] && [ -t 1 ]; then
    width=$(stty size < /dev/tty 2>/dev/null | cut -d' ' -f2)
  fi
  : "${width:=$(tput cols 2>/dev/null)}"
  : "${width:=100}"
  echo "$width"
}
export -f get_terminal_width

# Require jq to be installed (returns 1 with instructions if not)
require_jq() {
  if command -v jq >/dev/null 2>&1; then
    return 0
  fi
  echo "Error: jq is required but not installed." >&2
  echo "" >&2
  echo "Intent requires jq for JSON configuration parsing." >&2
  echo "" >&2
  echo "Installation instructions:" >&2
  if [ "$(uname)" = "Darwin" ]; then
    echo "  macOS: brew install jq" >&2
  elif [ "$(uname)" = "Linux" ]; then
    echo "  Debian/Ubuntu: sudo apt-get install jq" >&2
    echo "  RedHat/CentOS: sudo yum install jq" >&2
    echo "  Arch Linux: sudo pacman -S jq" >&2
  else
    echo "  Please install jq using your system's package manager" >&2
  fi
  echo "" >&2
  echo "For more information: https://stedolan.github.io/jq/download/" >&2
  return 1
}
export -f require_jq

# Require Claude Code to be installed
require_claude() {
  if [ -d "$HOME/.claude" ]; then
    return 0
  fi
  echo "Error: Claude Code not detected. Please install Claude Code first." >&2
  echo "Visit: https://claude.ai/download" >&2
  return 1
}
export -f require_claude

# Require a project root to be set (caller must load config first)
require_project_root() {
  if [ -n "${PROJECT_ROOT:-}" ]; then
    return 0
  fi
  echo "Error: Not in an Intent project directory" >&2
  echo "Run 'intent init' to create a new project first" >&2
  return 1
}
export -f require_project_root

# ---- Migration and Utility Functions ----

# Convert YAML frontmatter to JSON format
convert_yaml_frontmatter() {
  local file=$1
  local temp_file="${file}.tmp"
  
  # Check if file has YAML frontmatter
  if ! head -1 "$file" | grep -q "^---$"; then
    # No frontmatter, just copy the file to .tmp
    cp "$file" "$temp_file"
    return 0
  fi
  
  # Extract frontmatter and content
  local in_frontmatter=false
  local frontmatter=""
  local content=""
  local line_num=0
  
  while IFS= read -r line; do
    ((line_num++))
    if [ $line_num -eq 1 ] && [ "$line" = "---" ]; then
      in_frontmatter=true
    elif [ "$in_frontmatter" = true ] && [ "$line" = "---" ]; then
      in_frontmatter=false
    elif [ "$in_frontmatter" = true ]; then
      frontmatter="${frontmatter}${line}
"
    else
      content="${content}${line}
"
    fi
  done < "$file"
  
  # Convert common fields
  echo "---" > "$temp_file"
  
  # Extract and convert fields using more flexible parsing
  while IFS= read -r line; do
    if echo "$line" | grep -q "^stp_version:"; then
      # Convert stp_version to intent_version
      local version=$(echo "$line" | sed 's/stp_version:[[:space:]]*//')
      echo "intent_version: 2.0.0" >> "$temp_file"
    elif echo "$line" | grep -qE "^(verblock|status|created|completed|author):"; then
      # Keep these fields as-is
      echo "$line" >> "$temp_file"
    fi
  done <<< "$frontmatter"
  
  echo "---" >> "$temp_file"
  printf "%b" "$content" >> "$temp_file"
  
  # Replace original file
  mv "$temp_file" "$file"
}

# Update stp_version to intent_version in frontmatter
update_version_in_frontmatter() {
  local file=$1
  
  if [ ! -f "$file" ]; then
    return 1
  fi
  
  # Use sed to replace stp_version with intent_version
  if grep -q "^stp_version:" "$file"; then
    sed -i.bak 's/^stp_version:/intent_version:/' "$file"
    rm -f "${file}.bak"
  fi
}

# Convert YAML config to JSON config
convert_yaml_config_to_json() {
  local yaml_file=$1
  local json_file=$2
  
  # For .stp-config files, we need custom parsing
  if [ "$(basename "$yaml_file")" = ".stp-config" ]; then
    {
      echo "{"
      
      # Parse common fields from .stp-config
      local first=true
      while IFS= read -r line; do
        # Skip comments and empty lines
        if echo "$line" | grep -qE "^#|^$"; then
          continue
        fi
        
        # Extract key-value pairs
        if echo "$line" | grep -q ":"; then
          local key=$(echo "$line" | cut -d: -f1 | tr -d ' ')
          local value=$(echo "$line" | cut -d: -f2- | sed 's/^ *//' | tr -d '"')
          
          # Map old keys to new ones
          case "$key" in
            project_name)
              [ "$first" = false ] && echo ","
              echo -n "  \"project\": \"$value\""
              first=false
              ;;
            author)
              [ "$first" = false ] && echo ","
              echo -n "  \"author\": \"$value\""
              first=false
              ;;
            stp_dir|st_dir)
              # Skip these, we use standard names
              ;;
            editor)
              [ "$first" = false ] && echo ","
              echo -n "  \"editor\": \"$value\""
              first=false
              ;;
            default_status)
              # Skip, not used in v2.0.0
              ;;
          esac
        fi
      done < "$yaml_file"
      
      # Add standard v2.0.0 fields
      [ "$first" = false ] && echo ","
      echo "  \"intent_version\": \"2.0.0\","
      echo "  \"intent_dir\": \"intent\""

      echo "}"
    } > "$json_file"
  else
    # For other YAML files, try to use yq if available
    if command -v yq >/dev/null 2>&1; then
      yq -o json "$yaml_file" > "$json_file"
    else
      # Fallback: create minimal JSON
      echo "{" > "$json_file"
      echo "  \"intent_version\": \"2.0.0\"," >> "$json_file"
      echo "  \"intent_dir\": \"intent\"" >> "$json_file"
      echo "}" >> "$json_file"
    fi
  fi
}

# Create standard v2.0.0+ directory structure
create_v2_directory_structure() {
  local project_root=$1
  
  # Create directories
  mkdir -p "$project_root/.intent"
  mkdir -p "$project_root/intent/st/COMPLETED"
  mkdir -p "$project_root/intent/st/NOT-STARTED"
  mkdir -p "$project_root/intent/st/CANCELLED"
  mkdir -p "$project_root/intent/eng/tpd"
  mkdir -p "$project_root/intent/ref"
  mkdir -p "$project_root/intent/llm"
  # Create .gitignore if it doesn't exist
  if [ ! -f "$project_root/.gitignore" ]; then
    cat > "$project_root/.gitignore" << 'EOF'
# Intent/STP specific
.intent/local.json
*.bak
.backup_*

# OS specific
.DS_Store
Thumbs.db

# Editor specific
*.swp
*.swo
*~
.vscode/
.idea/
EOF
  fi
}

# Flatten nested directory structure
flatten_directory_structure() {
  local old_base=$1  # eg stp/prj/st
  local new_base=$2  # eg intent/st
  
  if [ ! -d "$old_base" ]; then
    return 0
  fi
  
  # Create new base directory
  mkdir -p "$new_base"
  
  # Move all contents
  if [ -n "$(ls -A "$old_base")" ]; then
    mv "$old_base"/* "$new_base/" 2>/dev/null || true
    mv "$old_base"/.[!.]* "$new_base/" 2>/dev/null || true
  fi
}

# Detect current STP/Intent version
detect_project_version() {
  local project_root=${1:-.}
  
  # Check for v2.0.0+ (Intent)
  if [ -f "$project_root/.intent/config.json" ]; then
    # Try intent_version first, then version field
    local version=$(jq -r '.intent_version // .version // empty' "$project_root/.intent/config.json" 2>/dev/null)
    if [ -n "$version" ]; then
      echo "$version"
      return 0
    fi
  fi
  
  # Check for v1.2.0+ (version file)
  if [ -f "$project_root/stp/.config/version" ]; then
    local version=$(grep "^stp_version:" "$project_root/stp/.config/version" | sed 's/stp_version:[[:space:]]*//')
    if [ -n "$version" ]; then
      echo "$version"
      return 0
    fi
  fi
  
  # Check for v0.0.0 (.stp-config)
  if [ -f "$project_root/.stp-config" ]; then
    echo "0.0.0"
    return 0
  fi
  
  # Check for directory structure patterns
  if [ -d "$project_root/stp/prj/st" ]; then
    # Has STP structure but no version - assume 1.0.0
    echo "1.0.0"
    return 0
  fi
  
  # Unable to determine version
  return 1
}

# Create backup of project
create_project_backup() {
  local project_root=$1
  local backup_dir=".backup_$(date +%Y%m%d_%H%M%S)"
  
  echo "Creating backup in $backup_dir..."
  mkdir -p "$project_root/$backup_dir"
  
  # Create backup manifest
  {
    echo "Backup created: $(date)"
    echo "Original version: $(detect_project_version "$project_root" || echo "unknown")"
    echo "Files backed up:"
  } > "$project_root/$backup_dir/manifest.txt"
  
  # Backup relevant directories and files
  for item in stp .stp-config .intent intent; do
    if [ -e "$project_root/$item" ]; then
      echo "Backing up $item..."
      cp -r "$project_root/$item" "$project_root/$backup_dir/"
      echo "  $item" >> "$project_root/$backup_dir/manifest.txt"
    fi
  done
  
  echo "$backup_dir"
}

# Check if migration is needed
needs_migration() {
  local version=$1
  
  # Already at v2.0.0
  if [ "$version" = "2.0.0" ]; then
    return 1
  fi
  
  # All other versions need migration
  return 0
}

# Display migration summary
show_migration_summary() {
  local from_version=$1
  local file_count=$2
  local backup_dir=$3
  
  echo ""
  echo "Migration Summary:"
  echo "  From version: $from_version"
  echo "  To version: 2.0.0"
  echo "  Files affected: $file_count"
  echo "  Backup location: $backup_dir"
  echo ""
}

# Count files that will be migrated
count_migration_files() {
  local project_root=$1
  local count=0
  
  # Count Markdown files
  if [ -d "$project_root/stp" ]; then
    count=$(find "$project_root/stp" -name "*.md" -type f | wc -l)
  fi
  
  # Add config files
  [ -f "$project_root/.stp-config" ] && ((count++))
  [ -f "$project_root/stp/.config/version" ] && ((count++))
  
  echo $count
}

# Alias for compatibility
detect_stp_version() {
  detect_project_version "$@"
}

# Check if needs v2 migration
needs_v2_migration() {
  local version=$1
  
  case "$version" in
    "2.0.0"|"2.1.0"|"2.2.0"|"2.2.1")
      return 1  # Already v2
      ;;
    *)
      return 0  # Needs migration
      ;;
  esac
}

# Check if needs 2.1.0 upgrade (agent initialization)
needs_v2_1_upgrade() {
  local version=$1
  
  case "$version" in
    "2.0.0")
      return 0  # Needs agent initialization
      ;;
    *)
      return 1  # Already upgraded or too old
      ;;
  esac
}

# Check if needs 2.2.0 upgrade (fileindex command)
needs_v2_2_upgrade() {
  local version=$1
  
  case "$version" in
    "2.0.0"|"2.1.0")
      return 0  # Needs fileindex upgrade
      ;;
    *)
      return 1  # Already upgraded or too old
      ;;
  esac
}

# Migrate v0.0.0 to v2.0.0
migrate_v0_to_v2() {
  local project_root=$1
  
  echo "Migrating v0.0.0 structure..."
  
  # Create new structure
  mkdir -p "$project_root/intent/st"
  mkdir -p "$project_root/intent/docs"
  
  # Migrate steel threads
  if [ -d "$project_root/stp/prj/st" ]; then
    for file in "$project_root/stp/prj/st"/ST*.md; do
      if [ -f "$file" ]; then
        local basename=$(basename "$file" .md)
        echo "  Migrating $basename..."
        mkdir -p "$project_root/intent/st/$basename"
        convert_yaml_frontmatter "$file"
        mv "$file.tmp" "$project_root/intent/st/$basename/info.md"
      fi
    done
  fi
  
  # Migrate other known files
  [ -f "$project_root/stp/prj/wip.md" ] && cp "$project_root/stp/prj/wip.md" "$project_root/intent/wip.md"
  [ -f "$project_root/stp/eng/tpd/technical_product_design.md" ] && cp "$project_root/stp/eng/tpd/technical_product_design.md" "$project_root/intent/docs/"
  
  # Migrate ALL remaining content to ensure nothing is left behind
  migrate_remaining_content "$project_root"
  
  # Create config
  local project_name=$(basename "$project_root")
  local author="${USER:-Unknown}"
  local target_version="$(get_intent_version 2>/dev/null || echo "2.2.1")"
  
  cat > "$project_root/.intent/config.json" << EOF
{
  "intent_version": "$target_version",
  "project_name": "$project_name",
  "author": "$author",
  "created": "$(date +%Y-%m-%d)",
  "st_prefix": "ST"
}
EOF
}

# Migrate v1.2.0 to v2.0.0
migrate_v1_2_0_to_v2() {
  local project_root=$1
  
  echo "Migrating v1.2.0 structure..."
  
  # Migrate steel threads (flat files)
  if [ -d "$project_root/stp/prj/st" ]; then
    for file in "$project_root/stp/prj/st"/ST*.md; do
      if [ -f "$file" ]; then
        local basename=$(basename "$file" .md)
        echo "  Migrating $basename..."
        mkdir -p "$project_root/intent/st/$basename"
        convert_yaml_frontmatter "$file"
        mv "$file.tmp" "$project_root/intent/st/$basename/info.md"
      fi
    done
  fi
  
  # Migrate other known content
  flatten_directory_structure "$project_root/stp/prj" "$project_root/intent"
  flatten_directory_structure "$project_root/stp/eng/tpd" "$project_root/intent/docs"
  flatten_directory_structure "$project_root/stp/llm" "$project_root/intent/llm"
  
  # Migrate ALL remaining content to ensure nothing is left behind
  migrate_remaining_content "$project_root"
  
  # Create config from existing YAML
  if [ -f "$project_root/stp/.config/config" ]; then
    convert_yaml_config_to_json "$project_root/stp/.config/config" "$project_root/.intent/config.json"
  else
    create_default_v2_config "$project_root"
  fi
}

# Migrate v1.2.1 to v2.0.0
migrate_v1_2_1_to_v2() {
  local project_root=$1
  
  echo "Migrating v1.2.1 structure..."
  
  # This project actually uses v1.2.0 structure with status directories
  # Migrate ALL steel threads from all locations
  if [ -d "$project_root/stp/prj/st" ]; then
    # First, migrate ST directories at the root level
    for dir in "$project_root/stp/prj/st"/ST*/; do
      if [ -d "$dir" ]; then
        local basename=$(basename "$dir")
        echo "  Migrating $basename..."
        mkdir -p "$project_root/intent/st/$basename"
        cp -r "$dir"/* "$project_root/intent/st/$basename/"
        
        # Update metadata in info.md
        if [ -f "$project_root/intent/st/$basename/info.md" ]; then
          convert_yaml_frontmatter "$project_root/intent/st/$basename/info.md" || true
          [ -f "$project_root/intent/st/$basename/info.md.tmp" ] && mv "$project_root/intent/st/$basename/info.md.tmp" "$project_root/intent/st/$basename/info.md"
        fi
      fi
    done
    
    # Then migrate from status directories (COMPLETED, NOT-STARTED, etc)
    for status_dir in "$project_root/stp/prj/st"/*/; do
      if [ -d "$status_dir" ] && [[ ! "$(basename "$status_dir")" =~ ^ST[0-9]+ ]]; then
        local status_name=$(basename "$status_dir")
        for st_dir in "$status_dir"/ST*/; do
          if [ -d "$st_dir" ]; then
            local basename=$(basename "$st_dir")
            echo "  Migrating $basename from $status_name..."
            mkdir -p "$project_root/intent/st/$status_name/$basename"
            cp -r "$st_dir"/* "$project_root/intent/st/$status_name/$basename/"
            
            # Update metadata in info.md
            if [ -f "$project_root/intent/st/$status_name/$basename/info.md" ]; then
              convert_yaml_frontmatter "$project_root/intent/st/$status_name/$basename/info.md" || true
              [ -f "$project_root/intent/st/$status_name/$basename/info.md.tmp" ] && mv "$project_root/intent/st/$status_name/$basename/info.md.tmp" "$project_root/intent/st/$status_name/$basename/info.md"
            fi
          fi
        done
      fi
    done
    
    # Copy steel_threads.md
    [ -f "$project_root/stp/prj/st/steel_threads.md" ] && cp "$project_root/stp/prj/st/steel_threads.md" "$project_root/intent/st/"
  fi
  
  # Migrate other known content
  [ -f "$project_root/stp/prj/wip.md" ] && cp "$project_root/stp/prj/wip.md" "$project_root/intent/"
  [ -d "$project_root/stp/eng/tpd" ] && cp -r "$project_root/stp/eng/tpd"/* "$project_root/intent/eng/tpd/" 2>/dev/null || true
  [ -d "$project_root/stp/llm" ] && cp -r "$project_root/stp/llm"/* "$project_root/intent/llm/" 2>/dev/null || true
  
  # Migrate ALL remaining content to ensure nothing is left behind
  migrate_remaining_content "$project_root"
  
  # Create config
  if [ -f "$project_root/stp/.config/config" ]; then
    convert_yaml_config_to_json "$project_root/stp/.config/config" "$project_root/.intent/config.json"
  else
    create_default_v2_config "$project_root"
  fi
}

# Migrate v2.0.0 to v2.1.0 (agent initialization)
migrate_v2_0_to_v2_1() {
  local project_root=$1
  
  echo "Upgrading v2.0.0 to v2.1.0 (agent initialization)..."
  
  # Update .intent/config.json to v2.1.0
  if [ -f "$project_root/.intent/config.json" ]; then
    echo "  Updating project version to 2.1.0..."
    local temp_file=$(mktemp)
    jq '.intent_version = "2.1.0" | del(.version)' "$project_root/.intent/config.json" > "$temp_file"
    mv "$temp_file" "$project_root/.intent/config.json"
  fi
  
  # Initialize user agent manifest if needed
  local user_manifest_dir="$HOME/.intent/agents"
  if [ ! -d "$user_manifest_dir" ]; then
    echo "  Initializing user agent configuration..."
    mkdir -p "$user_manifest_dir"
    cat > "$user_manifest_dir/installed-agents.json" << 'EOF'
{
  "version": "1.0.0",
  "installed": []
}
EOF
  fi
  
  echo "  Agent system initialized successfully"
}

# Migrate v2.1.0 to v2.2.0 (fileindex command)
migrate_v2_1_to_v2_2() {
  local project_root=$1
  
  echo "Upgrading v2.1.0 to v2.2.0 (fileindex command)..."
  
  # Update .intent/config.json to v2.2.0
  if [ -f "$project_root/.intent/config.json" ]; then
    echo "  Updating project version to 2.2.0..."
    local temp_file=$(mktemp)
    jq '.intent_version = "2.2.0" | del(.version)' "$project_root/.intent/config.json" > "$temp_file"
    mv "$temp_file" "$project_root/.intent/config.json"
  fi
  
  echo "  Fileindex command now available"
}

# Check if needs 2.2.1 upgrade
needs_v2_2_1_upgrade() {
  local version=$1
  
  case "$version" in
    "2.2.0")
      return 0  # Needs 2.2.1 upgrade
      ;;
    *)
      return 1  # Already upgraded or different version
      ;;
  esac
}

# Check if project needs v2.3.0 upgrade
needs_v2_3_0_upgrade() {
  local version=$1
  
  case "$version" in
    "2.0.0"|"2.1.0"|"2.2.0"|"2.2.1")
      return 0  # Needs 2.3.0 upgrade
      ;;
    *)
      return 1  # Already upgraded or different version
      ;;
  esac
}

# Check if project needs v2.3.1 upgrade
needs_v2_3_1_upgrade() {
  local version=$1
  
  case "$version" in
    "2.0.0"|"2.1.0"|"2.2.0"|"2.2.1"|"2.3.0")
      return 0  # Needs 2.3.1 upgrade
      ;;
    *)
      return 1  # Already upgraded or different version
      ;;
  esac
}

# Check if project needs v2.3.2 upgrade
needs_v2_3_2_upgrade() {
  local version=$1

  case "$version" in
    "2.0.0"|"2.1.0"|"2.2.0"|"2.2.1"|"2.3.0"|"2.3.1")
      return 0  # Needs 2.3.2 upgrade
      ;;
    *)
      return 1  # Already upgraded or different version
      ;;
  esac
}

needs_v2_3_3_upgrade() {
  local version=$1

  case "$version" in
    "2.0.0"|"2.1.0"|"2.2.0"|"2.2.1"|"2.3.0"|"2.3.1"|"2.3.2")
      return 0  # Needs 2.3.3 upgrade
      ;;
    *)
      return 1  # Already upgraded or different version
      ;;
  esac
}

needs_v2_3_4_upgrade() {
  local version=$1

  case "$version" in
    "2.0.0"|"2.1.0"|"2.2.0"|"2.2.1"|"2.3.0"|"2.3.1"|"2.3.2"|"2.3.3")
      return 0  # Needs 2.3.4 upgrade
      ;;
    *)
      return 1  # Already upgraded or different version
      ;;
  esac
}

needs_v2_4_0_upgrade() {
  local version=$1

  case "$version" in
    "2.0.0"|"2.1.0"|"2.2.0"|"2.2.1"|"2.3.0"|"2.3.1"|"2.3.2"|"2.3.3"|"2.3.4")
      return 0  # Needs 2.4.0 upgrade
      ;;
    *)
      return 1  # Already upgraded or different version
      ;;
  esac
}

needs_v2_5_0_upgrade() {
  local version=$1

  case "$version" in
    "2.0.0"|"2.1.0"|"2.2.0"|"2.2.1"|"2.3.0"|"2.3.1"|"2.3.2"|"2.3.3"|"2.3.4"|"2.4.0")
      return 0  # Needs 2.5.0 upgrade
      ;;
    *)
      return 1  # Already upgraded or different version
      ;;
  esac
}

# Migrate v2.2.0 to v2.2.1
migrate_v2_2_to_v2_2_1() {
  local project_root=$1
  
  local target_version="$(get_intent_version 2>/dev/null || echo "2.2.1")"
  echo "Upgrading v2.2.0 to v$target_version..."
  
  # Update .intent/config.json to target version
  if [ -f "$project_root/.intent/config.json" ]; then
    echo "  Updating project version to $target_version..."
    local temp_file=$(mktemp)
    jq --arg v "$target_version" '.intent_version = $v | del(.version)' "$project_root/.intent/config.json" > "$temp_file"
    mv "$temp_file" "$project_root/.intent/config.json"
  fi
  
  echo "  Version updated to $target_version"
}

# Generate basic AGENTS.md as fallback
_generate_basic_agents_md() {
  local project_root=$1
  cat > "$project_root/intent/llm/AGENTS.md" << 'EOF'
# AGENTS.md

## Project Overview
This is an Intent project. See CLAUDE.md for project-specific guidelines.

## Development Environment
### Prerequisites
- Bash 4.0 or higher
- POSIX-compliant shell environment

## Build and Test Commands
### Testing
```bash
# Check for test scripts in your project
intent doctor
```

## Code Style Guidelines
- Follow existing patterns in the codebase
- See CLAUDE.md for project-specific guidelines

## Intent-Specific Information
### Steel Thread Process
Work is organized into steel threads (ST####) under intent/st/

### Available Commands
- `intent st list` - List all steel threads
- `intent agents sync` - Update this AGENTS.md
- `intent claude subagents list` - List Claude subagents
EOF
  echo "    Generated basic AGENTS.md template"
}

# Migrate v2.2.x to v2.3.0 - Plugin architecture and AGENTS.md support
migrate_v2_2_to_v2_3_0() {
  local project_root=$1
  
  local target_version="$(get_intent_version 2>/dev/null || echo "2.3.0")"
  echo "Upgrading to Intent v$target_version with plugin architecture..."
  
  # 1. Create plugin directory structure
  echo "  Creating plugin architecture..."
  mkdir -p "$project_root/intent/plugins/claude/subagents"
  mkdir -p "$project_root/intent/plugins/agents/templates"
  
  # 2. Migrate agents to plugin location
  if [ -d "$project_root/agents" ]; then
    echo "  Migrating agents to plugin location..."
    if [ "$(ls -A "$project_root/agents" 2>/dev/null)" ]; then
      cp -r "$project_root/agents/"* "$project_root/intent/plugins/claude/subagents/" 2>/dev/null || true
    fi
    # Keep old agents directory for now, will be cleaned up later
  fi
  
  # 3. Create AGENTS.md if it doesn't exist
  if [ ! -f "$project_root/AGENTS.md" ] && [ ! -f "$project_root/intent/llm/AGENTS.md" ]; then
    echo "  Generating AGENTS.md..."
    mkdir -p "$project_root/intent/llm"
    
    # Try to use the smart generator via intent command
    if [ -f "$INTENT_HOME/bin/intent" ] && [ -f "$INTENT_HOME/intent/plugins/agents/bin/intent_agents" ]; then
      # Call the generator directly via intent command
      if (cd "$project_root" && "$INTENT_HOME/bin/intent" agents generate > "intent/llm/AGENTS.md" 2>/dev/null); then
        if [ -s "$project_root/intent/llm/AGENTS.md" ]; then
          echo "    Generated project-specific AGENTS.md"
        else
          # Fallback if generation produced empty file
          _generate_basic_agents_md "$project_root"
        fi
      else
        # Fallback if command failed
        _generate_basic_agents_md "$project_root"
      fi
    else
      # Fallback to basic template if Intent not properly installed
      _generate_basic_agents_md "$project_root"
    fi
    
    # Create symlink at project root
    ln -sf "intent/llm/AGENTS.md" "$project_root/AGENTS.md"
    echo "    Created AGENTS.md with symlink at project root"
  elif [ -f "$project_root/AGENTS.md" ] || [ -f "$project_root/intent/llm/AGENTS.md" ]; then
    echo "  AGENTS.md already exists, skipping generation"
  fi
  
  # 4. Update .intent/config.json
  if [ -f "$project_root/.intent/config.json" ]; then
    echo "  Updating configuration for v$target_version..."
    local temp_file=$(mktemp)
    jq --arg v "$target_version" '.intent_version = $v | del(.version) | .plugins = {"claude": {"subagents_path": "intent/plugins/claude/subagents"}, "agents": {"config_path": "intent/plugins/agents"}}' "$project_root/.intent/config.json" > "$temp_file"
    mv "$temp_file" "$project_root/.intent/config.json"
  fi
  
  # 5. Update CLAUDE.md with new commands
  if [ -f "$project_root/CLAUDE.md" ]; then
    echo "  Updating CLAUDE.md with v$target_version commands..."
    # Update agent commands to claude subagents
    sed -i.bak 's/`intent agents init`/`intent claude subagents init`/g' "$project_root/CLAUDE.md"
    sed -i.bak 's/`intent agents list`/`intent claude subagents list`/g' "$project_root/CLAUDE.md"
    sed -i.bak 's/`intent agents install/`intent claude subagents install/g' "$project_root/CLAUDE.md"
    rm -f "$project_root/CLAUDE.md.bak"
  fi
  
  echo "  Migration to v$target_version complete!"
  echo ""
  echo "  IMPORTANT CHANGES IN v2.3.0:"
  echo "    - 'intent agents' commands are now 'intent claude subagents'"
  echo "    - New 'intent agents' commands manage AGENTS.md"
  echo "    - Subagents moved to intent/plugins/claude/subagents/"
  echo "    - AGENTS.md provides universal AI agent instructions"
}

# Migrate v2.3.0 to v2.3.1 - Worker-bee agent integration
migrate_v2_3_0_to_v2_3_1() {
  local project_root=$1
  
  local target_version="$(get_intent_version 2>/dev/null || echo "2.3.2")"
  echo "Upgrading to Intent v$target_version with worker-bee agent..."
  
  # Update .intent/config.json to target version
  if [ -f "$project_root/.intent/config.json" ]; then
    echo "  Updating project version to $target_version..."
    local temp_file=$(mktemp)
    jq --arg v "$target_version" '.intent_version = $v | del(.version)' "$project_root/.intent/config.json" > "$temp_file"
    mv "$temp_file" "$project_root/.intent/config.json"
  fi
  
  # Check if worker-bee agent needs to be added to manifest
  if [ -f "$project_root/intent/plugins/claude/subagents/.manifest/global-agents.json" ]; then
    if ! grep -q "worker-bee" "$project_root/intent/plugins/claude/subagents/.manifest/global-agents.json"; then
      echo "  Adding worker-bee agent to global manifest..."
      # This would normally be done by the Intent installation, but we document it
      echo "    Note: Run 'intent claude subagents list' to see worker-bee agent"
    fi
  fi
  
  # Update CLAUDE.md if it exists and doesn't mention worker-bee
  if [ -f "$project_root/CLAUDE.md" ]; then
    if ! grep -q "worker-bee" "$project_root/CLAUDE.md"; then
      echo "  Note: CLAUDE.md may need updating to include worker-bee agent"
      echo "        Run 'intent doctor' to check for any issues"
    fi
  fi
  
  echo "  Migration to v$target_version complete!"
  echo ""
  echo "  IMPORTANT CHANGES IN v2.3.1:"
  echo "    - Added worker-bee agent for Worker-Bee Driven Design (WDD)"
  echo "    - Worker-bee agent includes resources directory with Mix tasks and templates"
  echo "    - Run 'intent claude subagents install worker-bee' to install the agent"
}

# Update config version helper function
update_config_version() {
  local project_root=$1
  local target_version=$2
  
  if [ -f "$project_root/.intent/config.json" ]; then
    local temp_file=$(mktemp)
    jq --arg v "$target_version" '.intent_version = $v | del(.version)' "$project_root/.intent/config.json" > "$temp_file"
    mv "$temp_file" "$project_root/.intent/config.json"
  fi
}

# Migrate v2.3.1 to v2.3.2 - Enhanced Elixir subagent with antipattern detection
migrate_v2_3_1_to_v2_3_2() {
  local project_root=$1
  
  local target_version="$(get_intent_version 2>/dev/null || echo "2.3.2")"
  echo "Upgrading to Intent v$target_version with enhanced Elixir subagent..."
  
  # Update config version
  echo "  Updating config version..."
  update_config_version "$project_root" "$target_version"
  
  # The Elixir subagent enhancements are handled by intent claude subagents sync
  echo "  Elixir subagent enhancements:"
  echo "    - Added comprehensive antipattern detection (24 patterns)"
  echo "    - Antipatterns categorized: Code, Design, Process, Meta-programming"
  echo "    - Full documentation at intent/plugins/claude/subagents/elixir/antipatterns.md"
  
  # Check if elixir subagent is installed
  if [ -f "$project_root/.claude/agents/elixir.md" ]; then
    echo "  Elixir subagent detected. Run 'intent claude subagents sync' to update."
  fi
  
  echo "  Migration to v$target_version complete!"
  echo ""
  echo "  IMPORTANT CHANGES IN v2.3.2:"
  echo "    - Enhanced Elixir subagent with antipattern detection"
  echo "    - Detects and remediates 24 common Elixir antipatterns"
  echo "    - Antipatterns sourced from official Elixir documentation"
  echo "    - Run 'intent claude subagents sync' to update installed agents"
}

# Migrate v2.3.2 to v2.3.3 - Add Elixir style guide to subagent
migrate_v2_3_2_to_v2_3_3() {
  local project_root=$1

  local target_version="$(get_intent_version 2>/dev/null || echo "2.3.3")"
  echo "Upgrading to Intent v$target_version with Elixir style guide..."

  # Update config version
  echo "  Updating config version..."
  update_config_version "$project_root" "$target_version"

  # The Elixir subagent style guide is handled by intent claude subagents sync
  echo "  Elixir subagent enhancements:"
  echo "    - Added comprehensive Elixir style guide"
  echo "    - Style guide covers: module organization, function definitions,"
  echo "      testing patterns, code composition, naming, documentation,"
  echo "      type specifications, dependency management, and database design"
  echo "    - Full documentation at intent/plugins/claude/subagents/elixir/style.md"

  # Check if elixir subagent is installed
  if [ -f "$project_root/.claude/agents/elixir.md" ]; then
    echo "  Elixir subagent detected. Run 'intent claude subagents sync' to update."
  fi

  echo "  Migration to v$target_version complete!"
  echo ""
  echo "  IMPORTANT CHANGES IN v2.3.3:"
  echo "    - Elixir subagent now includes comprehensive style guide"
  echo "    - Style guide complements antipattern detection from v2.3.2"
  echo "    - Run 'intent claude subagents sync' to update installed agents"
}

# Migrate v2.3.3 to v2.3.4 - Treeindex CLI, bug fixes, Elixir subagent expansion
migrate_v2_3_3_to_v2_3_4() {
  local project_root=$1

  local target_version="$(get_intent_version 2>/dev/null || echo "2.3.4")"
  echo "Upgrading to Intent v$target_version with treeindex and bug fixes..."

  # Update config version
  echo "  Updating config version..."
  update_config_version "$project_root" "$target_version"

  echo "  New features:"
  echo "    - 'intent treeindex DIR' command for LLM-optimized directory summaries"
  echo "    - .treeindexignore configuration for excluding files/dirs from indexing"
  echo "    - Centralized shadow directory at intent/.treeindex/"
  echo "  Bug fixes:"
  echo "    - Fixed 'intent init' displaying hardcoded version instead of actual version"
  echo "    - Fixed --sync flag bug in steel thread management"
  echo "  Enhancements:"
  echo "    - Expanded Elixir subagent with architectural principles and Ash/Phoenix patterns"

  # Check if elixir subagent is installed
  if [ -f "$project_root/.claude/agents/elixir.md" ]; then
    echo "  Elixir subagent detected. Run 'intent claude subagents sync' to update."
  fi

  echo "  Migration to v$target_version complete!"
  echo ""
  echo "  IMPORTANT CHANGES IN v2.3.4:"
  echo "    - New 'intent treeindex' command for codebase navigation"
  echo "    - Bug fixes for intent init and --sync"
  echo "    - Run 'intent claude subagents sync' to update installed agents"
}

# Migrate v2.3.4 to v2.4.0 - Skills system, diogenes subagent, upgrade command
migrate_v2_3_4_to_v2_4_0() {
  local project_root=$1

  local target_version="$(get_intent_version 2>/dev/null || echo "2.4.0")"
  echo "Upgrading to Intent v2.4.0 with skills system..."

  # Update config version
  echo "  Updating config version..."
  update_config_version "$project_root" "2.4.0"

  # Initialize skills manifest if needed
  local user_skills_dir="$HOME/.intent/skills"
  if [ ! -d "$user_skills_dir" ]; then
    echo "  Initializing skills configuration..."
    mkdir -p "$user_skills_dir"
    cat > "$user_skills_dir/installed-skills.json" << 'EOF'
{
  "version": "1.0.0",
  "installed": []
}
EOF
  fi

  # Check if subagents are installed and suggest sync
  if [ -d "$project_root/.claude/agents" ]; then
    echo "  Subagents detected. Run 'intent claude subagents sync' to update."
  fi

  echo "  Migration to v2.4.0 complete!"
  echo ""
  echo "  IMPORTANT CHANGES IN v2.4.0:"
  echo "    - New skills system: 'intent claude skills' commands"
  echo "    - Six skills available: intent-essentials, intent-elixir-essentials,"
  echo "      intent-ash-ecto-essentials, intent-phoenix-liveview,"
  echo "      intent-elixir-testing, intent-autopsy"
  echo "    - New diogenes subagent (Elixir Test Architect)"
  echo "    - New 'intent claude upgrade' command for project upgrades"
  echo "    - Steel thread improvements: slug field, --start flag"
  echo "    - Run 'intent claude skills list' to see available skills"
  echo "    - Run 'intent claude subagents sync' to update installed agents"
}

# Migrate v2.4.0 to v2.5.0 - Remove Backlog.md integration
migrate_v2_4_0_to_v2_5_0() {
  local project_root=$1

  local target_version="$(get_intent_version 2>/dev/null || echo "2.5.0")"
  echo "Upgrading to Intent v2.5.0 (Backlog.md removal)..."

  # 1. Remove backlog config keys from project config
  if [ -f "$project_root/.intent/config.json" ]; then
    echo "  Removing backlog configuration keys..."
    local temp_file=$(mktemp)
    jq --arg v "2.5.0" '.intent_version = $v | del(.version) | del(.backlog_dir) | del(.backlog_list_status)' "$project_root/.intent/config.json" > "$temp_file"
    mv "$temp_file" "$project_root/.intent/config.json"
  fi

  # 2. Remove backlog directory if it exists
  if [ -d "$project_root/backlog" ]; then
    echo "  Removing backlog/ directory..."
    rm -rf "$project_root/backlog"
    echo "    Removed backlog/ directory"
  fi

  # 3. Clean .gitignore of backlog entries
  if [ -f "$project_root/.gitignore" ]; then
    if grep -q "backlog" "$project_root/.gitignore"; then
      echo "  Cleaning backlog entries from .gitignore..."
      local temp_file=$(mktemp)
      grep -v "backlog" "$project_root/.gitignore" > "$temp_file"
      mv "$temp_file" "$project_root/.gitignore"
    fi
  fi

  # 4. Update CLAUDE.md to remove backlog references
  if [ -f "$project_root/CLAUDE.md" ]; then
    if grep -q "backlog" "$project_root/CLAUDE.md" 2>/dev/null; then
      echo "  Note: CLAUDE.md may contain backlog references."
      echo "        Run 'intent claude upgrade' to regenerate LLM guidance."
    fi
  fi

  echo "  Migration to v2.5.0 complete!"
  echo ""
  echo "  IMPORTANT CHANGES IN v2.5.0:"
  echo "    - Backlog.md integration has been removed"
  echo "    - Removed commands: bl, task, status, migrate, backlog"
  echo "    - Removed backlog_dir and backlog_list_status from config"
  echo "    - If you used Backlog.md, consider alternative task management"
  echo "    - Run 'intent claude upgrade' to update LLM guidance files"
}

# Migrate all remaining content from stp/ to intent/
migrate_remaining_content() {
  local project_root=$1
  
  echo "  Migrating any additional content..."
  
  # Migrate remaining content from stp/* (top level)
  if [ -d "$project_root/stp" ]; then
    for item in "$project_root/stp/"*; do
      if [ -e "$item" ]; then
        local basename=$(basename "$item")
        # Skip already handled directories and config
        if [[ "$basename" != "prj" && "$basename" != ".config" && "$basename" != "eng" && "$basename" != "llm" && "$basename" != "usr" ]]; then
          echo "    Migrating additional: stp/$basename"
          cp -r "$item" "$project_root/intent/" 2>/dev/null || true
        fi
      fi
    done
  fi
  
  # Migrate remaining content from stp/prj/* (except st/ and wip.md)
  if [ -d "$project_root/stp/prj" ]; then
    for item in "$project_root/stp/prj/"*; do
      if [ -e "$item" ]; then
        local basename=$(basename "$item")
        if [[ "$basename" != "st" && "$basename" != "wip.md" ]]; then
          echo "    Migrating additional: stp/prj/$basename"
          cp -r "$item" "$project_root/intent/" 2>/dev/null || true
        fi
      fi
    done
  fi
  
  # Migrate remaining content from stp/eng/* (except tpd/)
  if [ -d "$project_root/stp/eng" ]; then
    for item in "$project_root/stp/eng/"*; do
      if [ -e "$item" ]; then
        local basename=$(basename "$item")
        if [[ "$basename" != "tpd" ]]; then
          echo "    Migrating additional: stp/eng/$basename"
          mkdir -p "$project_root/intent/eng"
          cp -r "$item" "$project_root/intent/eng/" 2>/dev/null || true
        fi
      fi
    done
  fi
  
  # Migrate remaining content from stp/usr/*
  if [ -d "$project_root/stp/usr" ]; then
    echo "    Migrating stp/usr/ content"
    mkdir -p "$project_root/intent/usr"
    cp -r "$project_root/stp/usr/"* "$project_root/intent/usr/" 2>/dev/null || true
  fi
  
  # Update file references in all migrated files
  echo "  Updating file references..."
  find "$project_root/intent" -type f -name "*.md" -o -name "*.txt" | while read -r file; do
    # Update stp/ references to intent/
    sed -i.bak 's|stp/prj/st/|intent/st/|g' "$file" 2>/dev/null || true
    sed -i.bak 's|stp/prj/|intent/|g' "$file" 2>/dev/null || true
    sed -i.bak 's|stp/eng/|intent/eng/|g' "$file" 2>/dev/null || true
    sed -i.bak 's|stp/usr/|intent/usr/|g' "$file" 2>/dev/null || true
    sed -i.bak 's|stp/llm/|intent/llm/|g' "$file" 2>/dev/null || true
    # Clean up backup files
    rm -f "${file}.bak" 2>/dev/null || true
  done
}

# Create default v2 config
create_default_v2_config() {
  local project_root=$1
  local project_name=$(basename "$project_root")
  local author="${USER:-Unknown}"
  local target_version="$(get_intent_version 2>/dev/null || echo "2.2.1")"
  
  cat > "$project_root/.intent/config.json" << EOF
{
  "intent_version": "$target_version",
  "project_name": "$project_name",
  "author": "$author",
  "created": "$(date +%Y-%m-%d)",
  "st_prefix": "ST"
}
EOF
}

# Create CLAUDE.md for Intent v2.0.0+
create_claude_md() {
  local project_root=$1
  local force_overwrite=${2:-false}
  local project_name=$(jq -r '.project_name // "Project"' "$project_root/.intent/config.json" 2>/dev/null || echo "Project")
  local author=$(jq -r '.author // "Unknown"' "$project_root/.intent/config.json" 2>/dev/null || echo "${USER:-Unknown}")
  local version=$(jq -r '.intent_version // "2.0.0"' "$project_root/.intent/config.json" 2>/dev/null || echo "2.0.0")
  
  # Check if CLAUDE.md already exists
  if [ -f "$project_root/CLAUDE.md" ] && [ "$force_overwrite" != "true" ]; then
    return 0  # File exists and we're not forcing overwrite
  fi
  
  cat > "$project_root/CLAUDE.md" << EOF
# $project_name Project Guidelines

This is an Intent v$version project (formerly STP).

## Project Structure

- \`intent/\` - Project artifacts (steel threads, docs, work tracking)
  - \`st/\` - Steel threads organized as directories
  - \`docs/\` - Technical documentation
  - \`llm/\` - LLM-specific guidelines
- \`.intent/\` - Configuration and metadata

## Steel Threads

Steel threads are organized as directories under \`intent/st/\`:
- Each steel thread has its own directory (eg ST0001/)
- Minimum required file is \`info.md\` with metadata
- Optional files: design.md, impl.md, tasks.md

## Commands

- \`intent st new "Title"\` - Create a new steel thread
- \`intent st list\` - List all steel threads
- \`intent st show <id>\` - Show steel thread details
- \`intent agents init\` - Initialize agent configuration
- \`intent agents list\` - List available agents
- \`intent agents install <agent>\` - Install an agent
- \`intent doctor\` - Check configuration
- \`intent help\` - Get help

## Migration Notes

This project was migrated from STP to Intent v$version on $(date +%Y-%m-%d).
- Old structure: \`stp/prj/st/\`, \`stp/eng/\`, etc.
- New structure: \`intent/st/\`, \`intent/docs/\`, etc.
- Configuration moved from YAML to JSON format

## Author

$author
EOF
}